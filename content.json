{"posts":[{"title":"Hadoop伪分布式部署踩坑","text":"在上Hadoop分布式存储课时首先让我们部署一个简单的伪分布式存储系统，但是实机安装和机房老师已经弄好的快照还是十分不同的，踩了一些坑。 1. 启动namenode时，自动关闭查询 log (日志) 可以发现如下错误代码： 123hadoop-root-namenode-localhost.localdomain.logCall From hadoop to null:0 failed on socket exception:java.net.SocketException: Unresolved address 解决方法： 修改etc/hadoop目录下的core-site.xml，把hdfs://hadoop:9000中的hadoop改为本机ip。 或在namenode主机 hosts (主机) 将hadoop代理到本机ip。 2. namenode启动成功，关闭防火墙后无法访问50070端口解决方法： 先查看端口开放情况 netstat -ant 50070端口显示为 127.0.0.1:50070 将绑定IP改为0.0.0.0，而不是本地回环IP，这样，就能够实现外网访问本机的50070端口。 在hdfs-site.xml中修改添加如下代码： 123456hdfs-site.xml&lt;property&gt; &lt;name&gt;dfs.http.address&lt;/name&gt; &lt;value&gt;0.0.0.0:50070&lt;/value&gt;&lt;/property&gt;","link":"/posts/942/"},{"title":"Cloudflare 指定子域名 SSL 严格模式","text":"Cloudflare 的自定义性太强了。 背景我的博客采用 Vercel 作为评论服务的后端，而 Vercel 默认域名在大陆访问并非通畅，于是我换上了自己的子域名，但因为使用了 Cloudflare 的半程 SSL 并且 vercel 域名只支持 CNAME 解析，导致访问重定向次数过多。 如果开启严格 SSL 可以解决问题，但又会导致我没有放证书的 github pages 的主域名无法访问，因此有了以下曲线救国的解决方法。 解决方式通过 Cloudflare 设定 Configuration Rules，设定自定义筛选表达式。 当传入请求匹配时… 字段 运算符 值 URI 完整 包含 你想设定严格 SSL 的的子域名 则设置将为… SSL：严格","link":"/posts/18116/"},{"title":"Hello World","text":"Hello World ！ Hello World ！Hello World ！ Hello World ！Hello World ！","link":"/posts/63534/"},{"title":"Linux 输入&#x2F;输出重定向","text":"Linux 下输入/输入重定向简析 一个命令通常都会打开三个文件，默认使用文件描述符0, 1, 2来指代这个三个文件 123stdin 0 #标准输入流 （键盘）stdout 1 #标准输出流 （终端）stderr 2 #标准错误输出流 （终端） 输出重定向command 为任意命令，file为任意文件 12345command &gt; file #将标注输出重定向（写入）到 file 里command 1&gt; file #将标准输出重定向到 file 里（与上式一致）command 2&gt; file #将错误输出重定向到 file 里command &amp;&gt; file #将标准输出与错误输出一起重定向到 file 里command &gt;&gt; file #将标准输出追加到file中 例：标注输出至文件 1234567$ ls #展示当前目录test1 test2 test3$ ls &gt; test3 #将当前目录展示输出到test3文件中$ cat test3 #查看test3文件内容test1test2test3 例：错误输出至文件 123456789101112$ lstest1 test2 test3$ cat testxcat: testx: 没有那个文件或目录$ cat testx 2&gt;&gt; test3 #追加错误输出至test3文件中$ cat testcat: test: 没有那个文件或目录$ cat test3test1test2test3cat: testx: 没有那个文件或目录 例：标准输出与错误输出一同写入文件 12345678$ cat test2$ cat testxxxx test3 &amp;&gt; test2$ cat test2cat: testxxxx: 没有那个文件或目录test1test2test3cat: testx: 没有那个文件或目录 输入重定向xxx 为标签 12command &lt; file #重定向标准输入command &lt;&lt; xxx #多行输入 例：标注输入与命令读取的异同 123456$ head -v test1 #head -v展示文件内容以及文件名称==&gt; test1 &lt;==123$ head -v &lt; test1 #使用标准输入读取==&gt; 标准输入 &lt;==123 可见使用标准输入时，文件名称变为了标准输入。 例：标准输入实现多行输入 1234567891011$ head -v &lt;&lt;abc&gt; 123&gt; 123&gt; asd&gt; abc==&gt; 标准输入 &lt;==123123asd$ cat test1123 以上命令中，设定 abc 为结束标签，在多行输入结束时，输入abc，即识别标签并结束输入。 参考 https://gwaslab.com/2021/11/28/linux-redirection/","link":"/posts/59339/"},{"title":"Latex笔记","text":"记录一些Latex排版的技巧和坑。 对列表中新的段落增加缩进12\\usepackage{enumitem} %导言下加入\\setlist[enumerate]{listparindent=\\parindent} 表格中单元格自动换行1234567891011121314\\begin{table}[H] \\centering \\setlength{\\tabcolsep}{12mm}{ %设置列表宽度 \\caption{累积贡献率表}\\label{table_4-3} \\begin{tabular}{cp{11.8cm}} % cp{超出该值自动换行} 好像仅支持三线表，表格就得手动了。 \\toprule &amp; \\hspace{10em}部分药材编号 \\\\ \\midrule 1类 &amp; 1、17、32、35 39、40、45、46 \\\\ 2类 &amp; 2、5、8、11、13、15、16、18、22、24、25、26、27、28、29、33，34、36、37、38、43、44、47、49 \\\\ 3类 &amp; 1、4、6、7、9、10、12、14 19、20、21、23、24、30、31、35、36、37、41、42、48、50 \\\\ \\bottomrule \\end{tabular}}\\end{table} 为表格添加注释1234567891011121314151617181920\\begin{table}[H] \\centering \\caption{分波段方差分析表}\\label{table_4-4} \\setlength{\\tabcolsep}{17mm}{ %设定宽度一定要包在tabular外面一层 \\begin{tabular}{ccc} \\toprule 波段 &amp; F value &amp; P value \\\\ \\midrule $[901-950]$ &amp; 192.4 &amp; &lt;2e-16*** \\\\ %表格中[]中括号要加数学数学公式才能打出来 $[951-1000]$ &amp; 132.9 &amp; &lt;2e-16*** \\\\ $[1001-1050]$ &amp; 46.14 &amp; 1.13E-1*** \\\\ $[1051-1200]$ &amp; 78.06 &amp; &lt;2e-16*** \\\\ ... &amp; ... &amp; ... \\\\ \\bottomrule \\end{tabular}} \\begin{tablenotes} \\footnotesize \\item 注：*、**、***分别代表0．1、0，05、0.01的显著性水平 \\end{tablenotes}\\end{table} 图片并列排放12345678910111213\\begin{figure}[H] \\centering \\begin{minipage}[t]{0.48\\textwidth} %设定宽度 \\centering \\includegraphics[width=.8\\textwidth]{figure_4-24.jpg} \\caption{不同种类药材光谱数据均值曲线}\\label{figure_4-24} \\end{minipage} \\begin{minipage}[t]{0.48\\textwidth} \\centering \\includegraphics[width=.8\\textwidth]{figure_4-25.jpg} \\caption{不同种类药光谱数据标准差曲线}\\label{figure_4-25} \\end{minipage}\\end{figure} 图表编号混乱可以重置计数器1\\setcounter{table}{0} %重置table计数器 行内公式大小修正可以用的字体有: 1234\\displaystyle 标准\\textstyle 行内\\scriptstyle 第一层上下标\\scriptscriptstyle 第二层上下标 案例： 1$P=\\displaystyle{\\frac{T P}{T P+F P}}$ % \\displaystyle在数学公式符号内将需要修正大小的数学公式括起来 表格中单元格合并合并一行多列：\\multicolumn{cols}{pos}{text} 合并多行一列：\\multirow{rows}{width}{text} 123456789101112131415161718192021\\begin{table}[H] \\centering \\setlength{\\tabcolsep}{5.62mm}{ \\caption{累积贡献率表}\\label{table_5-3} \\begin{tabular}{cccccc} \\toprule 数据 &amp; 模型 &amp; 召回率 &amp; 精确率 &amp; 准确率 &amp; F1值 \\\\ \\midrule %\\multirow命令所覆盖的单元格需要用~代替 \\multirow{6}*{原始数据} &amp; SVC &amp; 0.869 &amp; 0.876 &amp; 0.871 &amp; 0.870 \\\\ ~ &amp; RF &amp; 0.500 &amp; 0.538 &amp; 0.535 &amp; 0.506 \\\\ ~ &amp; XGBoost &amp; 0.566 &amp; 0.599 &amp; .588 &amp; 0.568 \\\\ ~ &amp; GBDT &amp; 0.502 &amp; 0.520 &amp; 0.529 &amp; 0.500 \\\\ ~ &amp; LightGBM &amp; 0.570 &amp; 0.604 &amp; 0.600 &amp; 0.571 \\\\ ~ &amp; MLP &amp; 0.514 &amp; 0.538 &amp; 0.550 &amp; 0.509 \\\\ \\multirow{3}*{PCA降维数据} &amp; SVC &amp; 0.876 &amp; 0.869 &amp; 0.870 &amp; 0.871 \\\\ ~ &amp; RF &amp; 0.538 &amp; 0.500 &amp; 0.506 &amp; 0.535 \\\\ ~ &amp; XGBoost &amp; 0.599 &amp; 0. .566 &amp; 0.568 &amp; 0.588 \\\\ \\bottomrule \\end{tabular}}\\end{table} 表格续前表12345678910111213141516171819202122232425262728293031323334353637383940414243\\begin{center} \\setlength{\\tabcolsep}{5.62mm}{ \\begin{longtable}{cccccc} \\caption{基于机器学习方法的药材产地鉴别模型比较}\\\\ \\label{revenuepatternexplain} \\\\ \\endfirsthead %此命令以上为第一页表头 \\toprule %一条线 \\endhead %此命令以上为续前表的表头 数据 &amp; 模型 &amp; 召回率 &amp; 精确率 &amp; 准确率 &amp; F1值 \\\\ \\midrule \\multirow{7}*{原始数据} &amp; SVC &amp; 0.869 &amp; 0.876 &amp; 0.871 &amp; 0.870 \\\\ ~ &amp; RF &amp; 0.500 &amp; 0.538 &amp; 0.535 &amp; 0.506 \\\\ ~ &amp; XGBoost &amp; 0.566 &amp; 0.599 &amp; .588 &amp; 0.568 \\\\ ~ &amp; GBDT &amp; 0.502 &amp; 0.520 &amp; 0.529 &amp; 0.500 \\\\ ~ &amp; LightGBM &amp; 0.570 &amp; 0.604 &amp; 0.600 &amp; 0.571 \\\\ ~ &amp; MLP &amp; 0.514 &amp; 0.538 &amp; 0.550 &amp; 0.509 \\\\ \\multirow{7}*{PCA降维数据} &amp; SVC &amp; 0.876 &amp; 0.869 &amp; 0.870 &amp; 0.871 \\\\ ~ &amp; RF &amp; 0.538 &amp; 0.500 &amp; 0.506 &amp; 0.535 \\\\ ~ &amp; XGBoost &amp; 0.599 &amp; 0. .566 &amp; 0.568 &amp; 0.588 \\\\ ~ &amp; GBDT &amp; 0.539 &amp; 0.498 &amp; 0.500 &amp; 0.541 \\\\ ~ &amp; LighGBM &amp; 0.516 &amp; 0.473 &amp; 0.475 &amp; 0.512 \\\\ ~ &amp; MLP &amp; 0.521 &amp; 0488 &amp; 0.482 &amp; 0.521 \\\\ \\multirow{7}*{原始数据} &amp; SVC &amp; 0.914 &amp; 0.921 &amp; 0.913 &amp; 0.916 \\\\ ~ &amp; RF &amp; 0.915 &amp; 0.929 &amp; 0.927 &amp; 0.915 \\\\ ~ &amp; XGBoost &amp; 0.970 &amp; 0.974 &amp; 0.970 &amp; 0.920 \\\\ ~ &amp; GBDT &amp; 0.881 &amp; 0.889 &amp; 0.900 &amp; 0.883 \\\\ ~ &amp; LightGBM &amp; 0.964 &amp; 0.968 &amp; 0.964 &amp; 0.964 \\\\ ~ &amp; MLP &amp; 0.813 &amp; 0.839 &amp; 0.828 &amp; 0.817 \\\\ \\multirow{7}*{原始数据} &amp; SVC &amp; 0.861 &amp; 0.868 &amp; 0.863 &amp; 0.860 \\\\ ~ &amp; RF &amp; 0.869 &amp; 0.882 &amp; 0.857 &amp; 0.861 \\\\ ~ &amp; XGBoost &amp; 0.915 &amp; 0.935 &amp; 0.921 &amp; 0.920 \\\\ ~ &amp; GBDT &amp; 0.793 &amp; 0.834 &amp; 0.816 &amp; 0.799 \\\\ ~ &amp; LightGBM &amp; 0.923 &amp; 0.932 &amp; 0.925 &amp; 0.923 \\\\ ~ &amp; MLP &amp; 0.812 &amp; 0.820 &amp; 0.815 &amp; 0.809 \\\\ \\multirow{7}*{原始数据} &amp; SVC &amp; 0.824 &amp; 0.835 &amp; 0825 &amp; 0.823 \\\\ ~ &amp; RF &amp; 0.834 &amp; 0.871 &amp; 0.853 &amp; 0.841 \\\\ ~ &amp; XGBoost &amp; 0.881 &amp; 0.897 &amp; 0.887 &amp; 0.884 \\\\ ~ &amp; GBDT &amp; 0.814 &amp; 0.835 &amp; 0.822 &amp; 0.822 \\\\ ~ &amp; LightGBM &amp; 0.850 &amp; 0.866 &amp; 0.854 &amp; 0.853 \\\\ ~ &amp; MLP &amp; 0.787 &amp; 0.795 &amp; 0.790 &amp; 0.785 \\\\ \\bottomrule \\end{longtable}}\\end{center} 简单三线表1234567891011121314\\begin{table}[H] \\centering \\setlength{\\tabcolsep}{12mm}{ %设置列表宽度 \\caption{各管线费用}\\label{table_1} \\begin{tabular}{cc} \\toprule 管线 &amp; 铺设费用 \\\\ \\midrule A炼油厂 &amp; 5.6万元/km \\\\ B炼油厂 &amp; 6.0万元/km \\\\ 共用管线 &amp; 7.2万元/km \\\\ \\bottomrule \\end{tabular}}\\end{table} 公式中实现等号对齐123456\\begin{equation} \\begin{split} f(x, y, m) = &amp; P_{1} \\sqrt{x^{2}+(y-a)^{2}}+P_{2} \\sqrt{(c-x)^{2}+(b-m-y)^{2}} \\\\ &amp; +\\left(Q+P_{2}\\right) \\sqrt{(l-c)^{2}+m^{2}}+ P^{\\prime} y \\end{split}\\end{equation}\\label{eqx1} 引用文献实现超链接1\\cite{bib:seven} 并列图片123456789101112131415\\end{table}\\begin{figure}[H] \\centering \\caption{LDA与SVM在近红外光谱数据中的混淆矩阵示意图}\\label{LDA_SVM} \\begin{minipage}[t]{0.48\\textwidth} \\centering \\includegraphics[width=.9\\textwidth]{近红外_LDA.eps} \\caption*{LDA} \\end{minipage} \\begin{minipage}[t]{0.48\\textwidth} \\centering \\includegraphics[width=.9\\textwidth]{近红外_SVM.eps} \\caption*{SVM} \\end{minipage}\\end{figure}","link":"/posts/59143/"},{"title":"MATLAB基于问题的整数线性规划","text":"这几天做题遇到了较为复杂的规划问题，在想能不能用MATLAB实现像LINGO那样的偏向用户输入的编写方法，而非MATLAB矩阵式的，最终实现了基于问题的求解代码。 \\begin{equation} A = \\begin{bmatrix} a & b \\\\ c & c \\end{bmatrix} \\end{equation} \\begin{equation}\\ \\begin{array}{c} \\begin{aligned} \\max \\quad \\mathrm{E} = \\frac{Q-F-T}{F+T} \\times 100 \\% \\\\ \\end{aligned} \\\\ \\begin{aligned} s \\cdot t\\left\\{\\begin{array}{l} \\frac{\\sum_{i = 1}^{8} b_{i} \\cdot x_{i}}{L} \\leq 2.28 \\\\ m_{i} \\leq x_{i} \\leq M_{i} \\\\ \\sum_{i = 1}^{11} x_{i} \\cdot r_{i} \\geq 0.7069 \\cdot \\theta \\quad 0 \\quad 0","link":"/posts/25548/"},{"title":"Matlab数学建模笔记","text":"记录使用Matlab解决数学建模问题中遇到的坑。 数据拟合[P,S,mu] = polyfit(x,y,n) 给出在最小二乘一一下最佳拟合系数 函数根据采样点x, y，产生一个n次多项式P及其在采样点的误差向量S x, y为等长向量 P为长度为m+1的向量 图片X轴过小12345678910XX = [170 120 180 200 190 220; 120 100 110 180 170 180; 70 50 80 100 95 120];[Data, TextData] = xlsread('sj.xlsx');bar(Data,'stacked')set(gca,'xtick',1:31,'xticklabel',[&quot;北京&quot;,&quot;天津&quot;,&quot;河北&quot;,&quot;山西&quot;,&quot;内蒙古&quot;,&quot;辽宁&quot;,&quot;吉林&quot;,&quot;黑龙江&quot;,&quot;上海&quot;,&quot;江苏&quot;,&quot;浙江&quot;,&quot;安徽&quot;,&quot;福建&quot;,&quot;江西&quot;,&quot;山东&quot;,&quot;河南&quot;,&quot;湖北&quot;,&quot;湖南&quot;,&quot;广东&quot;,&quot;广西&quot;,&quot;海南&quot;,&quot;重庆&quot;,&quot;四川&quot;,&quot;贵州&quot;,&quot;云南&quot;,&quot;西藏&quot;,&quot;陕西&quot;,&quot;甘肃&quot;,&quot;青海&quot;,&quot;宁夏&quot;,&quot;新疆&quot;])% 使用set命令的'xtick',1:31参数更改X轴显示legend(&quot;食品&quot;,&quot;衣着&quot;,&quot;设备&quot;,&quot;医疗&quot;,&quot;交通&quot;,&quot;教育&quot;,&quot;居住&quot;,&quot;杂项&quot;)xlabel('不同城市的八个方面');ylabel('一年的消费情况');grid ontitle('31个城市的不同消费情况') 高斯平滑处理1234567%高斯数据平滑处理，高斯滤波b = smoothdata(a,&quot;gaussian&quot;,500);x_gj1=b(:,1);z_gj1=b(:,2);x_a=a(:,1);z_a=a(:,2);plot(x_gj1,z_gj1,x_a,z_a)","link":"/posts/53370/"},{"title":"《上帝的笔误》疑点分析","text":"看这部电影还是蛮曲折的，两天断断续续的才看完，主要是前半段确实铺垫较多，节奏较慢，后半部分着实精彩，现在来回顾一些关于影片的疑点和思考。 语言带来的大概是语言的问题，我虽看过《看不见的客人》，也看过许多欧洲那些非英语的片子，但是还是打心底对这些小语种感到迷茫。这种感觉就像以前从来不看日本动漫，便对日语有一种奇怪的排斥感，随着接触越来越多，就逐渐适应了。 如同以前第一次看北欧的挪威的片，第一次听到挪威语，叽里呱啦的，此时观看奥里奥尔·保罗这部西班牙语的电影，也是那种好久不见的感受。 题材反转反转再反转，对于经常看悬疑片的我来说已经见怪不怪了（bushi）。不能说精神病院这种题材烂大街，只是在观看之前，我就能够意识到这是一部对精神病有所刻画以及在剧情中会以此为主线基调的电影，所以有了一些准备，后面的反转只能说是意料之中。 不过对于电影的镜头语言我非常喜欢，开场女主坐在车里看向镜头外的观众、被治疗后产生的与前医生 Donadio 的对话的幻象等等场面，都非常令人惊艳。有一种石子落入水滴荡起波澜的感觉，好像随着女主的侦探视角，一步步剥开“事实”，有种《夏日重现》中慎平俯瞰的那味儿。 思考对于女主是否是精神病的问题，我想通过开头私人医生 Donadio 写的信以及结尾私人医生 Donadio 直接跳脸对峙时女主的微表情，不难看出这是高智商精神病女主在最后计划败露的不甘与害怕。 所谓的“事实”，是女主用各个谎言的连环自证，得出的一个她能离开精神病院的结论。 关于故事我不想再赘述回顾，讲一些别人可能没注意到，我觉得可以证明女主有问题的疑点： 在纵火那段剧情中，女主作案前寻求精神病人们的帮助，所有人都点头同意了，虽然说他们是精神病人，思维也许和正常人有所偏差，但对于没怎么相处的女主，却都表现出一副乐意帮助的态度，我觉得这可能是女主曾经在这所精神病院呆过的原因。 电影故事分为三条事件线，第一条是女主调查杀人事件，第二条是侏儒死亡事件，第三条是女主制造动乱事件。 侏儒死亡事件感觉和主线无关，但可以剧情中可以看到女主自然的接受了作为双胞胎母亲，以及在教堂时双胞胎之一和女主的对视，不难让观众对于他们之间的关系有一些想法。有没有一种可能，女主在之前的住院经历中生下了双胞胎呢。 影片的第一条事件与第三条事件重复度极高，如果导演有误导观众的意思，也就是第一事件真实发生，而且确实是自杀，但叙述片段使用的是女主引起的第三条事件，那么我觉得很没意思，纯纯把观众当傻子。 引用契诃夫的名言：“请将一切与故事无关的事物都从故事中移除。如果你说第一幕中有把枪挂在墙上，那么在第二幕或者第三幕中这把枪必须发射，不然就没必要挂在那。” 所以以我而言，如果第一条事件也是第三条事件，那么作为一个高智商精神病人，她入院的谎言就是故事的基础，在这个谎言的基础上，她想象出了自己如何能够走出精神病院的大致方案，也就是观众们看到的第一条女主作为侦探调查死亡的事件（这时是女主的想象，也是后来的现实），接着一环扣一环，女主逐步实现了计划。借用网友的一句话：女主在循环自己。 值得注意的是，除了开场是以女主视角来推进的以外，后来的故事基本都是第三视角看待女主，并非女主内心视角，因此对于观众所看到的，也是女主的“谎言”。 片尾女主自证时说老公没有留下任何蛛丝马迹，私人医生 Donadio 在苏黎世失踪了，她如何知道的？且她说私人医生失踪时，镜头切换到了院长警惕的神态，可以知道院长在思考怎样合适地揭穿她了，也就是说从这个时候起院长投不投票已经无所谓，他反正也“被迫”辞职了，事不关己，打那些医生的脸就行。后续就是私人医生 Donadio 马上回来说她在搞什么飞机。（这好像太明显了） 女主为了破案，强行伪装成偏执狂进精神病院这件事情本身也太偏执狂了。很符合院长说的优越感和自负。 至于说那几个帮助女主的医生可能与女主做了交易，或者那个女医生想顶替院长，我觉得有可能但概率不大。 所以总的来说，女主有精神问题，也确实是侦探，私人医生 Donadio 真实存在，女主给丈夫下毒也真实发生，丈夫恶意卷款送女主入院也真实发生，院长收钱了但是走的公账，他是真想治女主的病。 评价我觉得这部片很好，但是坏在哪里呢，坏就坏在故意引导观众去思考的部分过多了，会导致各种逻辑都无法自洽，观点对冲过多了，有一种用力过猛的不适感。 个人主观评价：7.5 分。","link":"/posts/40556/"},{"title":"Java基础","text":"关于Java基础的杂记 第一章 序万丈高楼平地起。 第二章 概述java 转义字符\\\\t ：一个制表位，实现对齐功能\\\\n ：换行符\\\\\\ ：一个真实的斜杠\\\\” ： 一个真实的双引号\\\\’ ： 一个真实的单引号\\\\r ：一个回车，没有换行，将光标置于最前，逐个输出\\r 后的字符 注释 单行注释 1//需要注释的语句 多行注释 123/*这里是多行注释*/ Javadoc 注释 1234/** * @author lael * @version 1.0 */ 细节 注释语句不会执行。 代码规范 类、方法的注释，要以 javadoc 的方式来写。 非 javadoc 注释着重告诉维护者如何修改、为什么这样写，以及注意事项。 运算符和 = 两边加一个空格。 实际工作使用 UTF-8 编码格式。 行宽不超过 80 字符。 代码编写使用行尾风格或次行风格。 一段代码一个模块，尽量只写一个功能，避免混乱。 JDK、JRE、JVM 之间关系 JDK = JRE + JAVA 开发工具 JRE = JVM + 核心类库 第三章 变量变量注意事项 int 4 个字节、double 8 个字节，每个类型占用空间不同。 变量必须先声明，后使用。 变量在同一个作用域中不可重名。 变量 = 变量名 + 值 + 数据类型 （三要素）。 + 号 当 + 左右两边有一方为字符串，则做拼接运算。 两边均为数值类型，则做加法运算。 运算顺序为从左到右。 数据类型 数值型 整数：byte[1]、short[2]、int[4]、long[8] 浮点数（小数）：float[4]、double[8] 字符型 char[2]：存放单个字符，如 ‘a’ 布尔型 boolean[1]：存放 true/false 整型使用细节 java 整型常量默认为 int 类型，声明 long 型常量须后加 ‘l’ 或 ‘L’ bit：计算机中最小存储单位 byte：计算机中基本存储单位 1 byte = 8 bit 浮点型使用细节 默认为 double 类型，声明 float 型单精度常量须后加 ‘f’ 或 ‘F’ 表示形式： 十进制 科学计数法，如：5.12e10 = 5.12 x 1010 通常情况下应该使用 double，因为它比 float 更精确，而 float 会损失一些小数位 字符型使用细节 字符常量用单引号括起单个字符 允许使用转义字符 char 的本质是一个整数，所以可以直接给 char 赋值整数，输出时是对应 unicode 对应字符 char 类型可以进行运算 基本数据类型的转换 精度小的类型自动转换为精度大的数据类型 char int long float double byte short int long float double 有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的数据类型，再进行计算 精度大的赋值给精度小的数据类型就会报错 (byte, short) 和 char 之间不会相互自动转换 byte, short, char 三者之间可以计算，在计算时首先转换为 int 类型 boolean 不参与类型自动转换 强制转换细节 需要数据从大到小时，就需要使用强制转换 字符串转换基本类型12345678int num1 = Integer.parseInt(s5);double num2 = Double.parseDouble(s5);float num3 = Float.parseFloat(s5);long num4 = Long.parseLong(s5);byte num5 = Byte.parseByte(s5);boolean b = Boolean.parseBoolean(&quot;true&quot;);short num6 = Short.parseShort(s5);char num7 = s5.charAt(0); //获取字符串的第一个字符 转换错误类型，会抛出异常，程序终止 第四章 运算符% 取余，取模123456// % 取模，取余// 本质公式：a % b = a - a / b * bSystem.out.println(10 % 3); //1System.out.println(-10 % 3); //-1System.out.println(10 % -3); //1System.out.println(-10 % -3); //-1 ++ 自增 / — 自减123456789101112131415// ++ 自增int i = 10;i++; //自增 等价于 i = i + 1 =&gt; i = 11++i; //自增 等价于 i = i + 1 =&gt; i = 12System.out.println(&quot;i=&quot; + i);/*作为表达式使用前++ ：++i先自增后赋值后++ ：i++先赋值后自增*/int j = 8;// int k = ++j; //等价于 j = j + 1; k = j;int k = j++; //等价于 k = j; j = j + 1;System.out.println(&quot;k=&quot; + k + &quot;\\nj=&quot; + j); 逻辑运算符逻辑与 &amp;对于逻辑与，第一个条件为 false，后面条件仍会判断执行 短路与 &amp;&amp;对于短路与，第一个条件为 false，后面条件不再判断执行 逻辑或 |对于逻辑或，第一个条件为 true，后面条件仍会判断执行 逻辑或 ||对于短路或，第一个条件为 true，后面条件不再判断执行 异或操作 ^a ^ b，如果 a 与 b 结果不同，则为 true，否则为 false 取反操作 ~对参数二进制格式进行 01 取反 三元运算符条件表达式 ？ 表达式1 : 表达式2 如果条件表达式为 true，运算后的结果是表达式 1 如果条件表达式为 false，运算后的结果是表达式 2 1234int a = 10;int b = 99;int result = a &gt; b ? a++ : b--;System.out.println(&quot;result: &quot; + result + &quot;\\nb: &quot; + b); 原码、反码、补码重要：负数的计算，需要先从原码转换为反码，反码再转换为补码再进行位运算，运算完毕后，再依次转回反码、原码。 二进制的最高位是符号位：0 表示正数，1 表示负数。 正数源码、反码、补码都一样。 负数的 反码 = 它的原码符号位不变，其他位取反。 负数的 补码 = 反码 + 1，反码 = 补码 -1。 0 的反码，补码都是 0。 java 没有无符号数。 计算机运算都以补码方式运算。 看运算结果的时候，要看它的原码。 位运算符按位与 &amp;两者全为 1，结果为 1，否则为 0。 12345678//1. 先得到 2 的补码 =&gt; 2的原码 00000000 00000000 0000000 0000010//2. 3的补码 3的原码 00000000 00000000 0000000 0000011//3. 按位与 &amp;// 00000000 00000000 0000000 0000010// 00000000 00000000 0000000 0000011//4. 得到是运算后的补码，因为是正数，三码合一，也是原码// 00000000 00000000 0000000 0000010 =&gt; 2System.out.println(2&amp;3);//2 按位或 |两位有一个为 1，结果为 1，否则为 0 1234//1. 先得到 2 的补码 = 2的原码 00000000 00000000 0000000 0000010//2. 3的补码 = 3的原码 00000000 00000000 0000000 0000011//3. 按位或 | 得到 00000000 00000000 0000000 0000011 =&gt; 3System.out.println(2|3);//3 按位异或 ^两位有一个为 0，一个 1，结果为 1，否则为 0 1234//1. 先得到 2 的补码 = 2的原码 00000000 00000000 0000000 0000010//2. 3的补码 = 3的原码 00000000 00000000 0000000 0000011//3. 按位异或 ^ 得到 00000000 00000000 0000000 0000001 =&gt; 1System.out.println(2^3);//1 按位取反 ~0 -&gt; 1，1 -&gt; 0 123456789101112//1. 先得到 -2 的原码 10000000 00000000 00000000 00000010//2. -2 的反码 11111111 11111111 11111111 11111101//3. -2 的补码 11111111 11111111 11111111 11111110//4. ~-2 操作 00000000 00000000 00000000 00000001 运算后的补码//5. 运算后的原码就是 00000000 00000000 00000000 00000001 =&gt; 1System.out.println(~-2);//1//1. 得到2的补码 0000000 00000000 00000000 00000010 正数原码、补码、反码三合一//2. ~2 操作 11111111 11111111 11111111 11111101 运算后的补码（负数）//3. 运算后的反码 11111111 11111111 11111111 11111100 反码 = 补码 - 1（负数）//4. 运算后的原码 10000000 00000000 00000000 00000011 =&gt; -3System.out.println(~2); //-3 算数左移运算符 &lt;&lt;符号位不变，按二进制位数左移指定位数，低位补 0。 算数右移运算符 &gt;&gt;低位溢出，符号位不变，并用符号位补溢出的高位。 1234567//1. 先得到 -1 的原码 10000000 00000000 0000000 00000001//2. 得到反码 11111111 11111111 11111111 11111110//3. 转换为补码 11111111 11111111 11111111 11111111//4. &gt;&gt;2操作 11111111 11111111 11111111 11111111//5. 转换为反码 11111111 11111111 11111111 11111110//6. 转换为原码 操作 10000000 00000000 00000000 00000001 =&gt; -1int b = -1 &gt;&gt; 2; //-1 逻辑右移操作符 &gt;&gt;&gt;低位溢出，高位补 0。 标识符的命名规则和规范^cd9c26 标识符概念 Java 中对各种变量、方法和类等命名时使用的字符序列称为标识符 凡是自己起名字的地方都称为标识符 命名规则 由 26 个英文字母大小写，0-9，或$组成 不可以使用数字开头 不可以使用关键字和保留字，但可以包含 严格区分大小写，长度无限制 标识符不能包含空格 包名多单词组成时所有字母小写 例：com.hahah.cpm 类名 、接口名多单词组成时，所有单词首字母大写 [大驼峰] 例：TankShotGame 变量名、方法名多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写 [小驼峰] 例：tankShotGame 常量名所有字母都大写，多个单词时用下划线连接 例：定义一个所得税税率 TAX_RATE 进制二进制0,1，满 2 进 1，以 0b 或 0B 开头 转八进制从低位(右)开始，将二进制数每三位一组，转成对应八进制数。 例：0b11010101 转为八进制 0b11(3)010(2)101(5) = 325 十进制0-9，满 10 进 1 转二进制将十进制数不断除以 2，直到商为 0，再将每步得到的余数倒置，就是对应的二进制 例：十进制 34 转为二进制 0b100010 转八进制将十进制数不断除以 8，直到商为 0，再将每步得到的余数倒置，就是对应的八进制 例：十进制 131 转为八进制 0203 转十六进制将十进制数不断除以 16，直到商为 0，再将每步得到的余数倒置，就是对应的十六进制 例：十进制 237 转为十六进制 0xED 八进制0-7，满 8 进 1，以数字0开头 转二进制将八进制数每 1 位转换为对应 3 位二进制 例：八进制 0237 转为二进制 0b010011111 十六进制0-9以及A(10)-F(15)， 满 16 进 1，以0x或0X开头 A-F不区分大小写 转二进制将十六进制数每 1 位转换为对应 4 位二进制 例：十六进制 0x23B 转为二进制 0b001000111011 第五章 控制结构顺序控制从上到下逐行执行，中间没有任何判断和跳转，遵循向前引用原则。 分支控制if else如果表达式为 true，则执行语句块 1，如果表达式为 false，则执行语句块 2。 双分支： 12345if (表达式) { 语句块1;} else { 语句块2;} 多分支： 12345678910if(表达式1) { 语句块1;} else if(表达式2) { 语句块2;...} else if(表达式n) { 语句块n;} else { 语句块n+1;} 如果表达式 1 为 true，则执行语句块 1，如果表达式 1 为 false，则继续判断表达式 2，为 true 则执行语句块 2，以此类推。 特别说明： 多分支可以没有 else。 如果所有表达式都不成立，则默认执行 else 代码块。 嵌套分支： 12345678910111213141516171819if(表达式1) { if(表达式2) { 语句块1; } else { 语句块2; }} else { if(表达式3) { 语句块3; } else if(表达式4) { 语句块4; } else { if(表达式n) { 语句块n; } else { 语句块n+1; } }} 实际开发中，嵌套不要超过三层，可读性不好。 switch表达式对应一个值，当表达式的值等于值 1，就执行语句块 1，并break跳出 swtich，不等于值 1 便逐次与值 2、值 3……进行匹配。如果表达式和值一个都没有匹配上，就默认执行 default 语句块。 如果不加break，则发生穿透，执行完该值的语句块并继续进行下一个值的判断。 123456789101112131415switch(表达式) { case 值1: 语句块1; break; case 值2: 语句块2; break; … case 值n: 语句块n; break; default: 语句块n+1; break;} switch 细节讨论： 表达式数据类型应与case后的常量类型一致，或者是能够自动转换或比较的类型。如char与int类型可以相互转换。 switch 中的表达式的返回值必须是：byte, short, int, char, enum[枚举], String 中的一种。 case子句中的值必须是常量（1, ‘a’）或者是常量表达式，不能是变量。 default的子句是可选的，当没有匹配的case时，执行default。 break用于退出 switch，如果没有，程序会进行穿透，执行到 switch 结尾。 123456789101112131415161718192021222324252627//3. 季节判断，使用穿透。System.out.println(&quot;输入月份：&quot;);int season = myScanner.nextInt();switch (season) { case 3: case 4: case 5: System.out.println(&quot;春季。&quot;); break; case 6: case 7: case 8: System.out.println(&quot;夏季。&quot;); break; case 9: case 10: case 11: System.out.println(&quot;秋季。&quot;); break; case 1: case 2: case 12: System.out.println(&quot;冬季。&quot;); break; default: System.out.println(&quot;月份错误！&quot;);} switch 与 if 的比较 如果判断具体数值不多，并且符合 byte, short, int, char, enum[枚举], String 这六种类型，建议使用 switch 语句。 对于区间判断、结果为 boolean 类型的判断，使用 if 的范围更广。 循环控制for123for(循环变量初始化; 循环条件; 循环变量迭代) { 语句块; //只有一句语句可以省略 {}。} for 循环细节： 循环条件应返回一个布尔值的表达式。 初始化变量和变量迭代可以写到其他地方，分号不能省略。 12345int i = 1; //循环变量初始化for (; i &lt;= 10;) { System.out.println(&quot;你好&quot; + i); i++; //循环变量迭代} 循环变量初始值可以有多条初始化语句，但是要求类型一致，循环遍历迭代同理。 while先判断，再循环。 123while(条件表达式) { 语句块;} do while先执行，再判断，一定会执行一次。 123do { 语句块;}while(条件表达式); 循环嵌套将一个循环放在另一个循环体内，内层循环作为外层循环的执行代码。 九九乘法表： 1234567891011public static void main(String[] args) { System.out.println(&quot;乘法口诀表：&quot;); // 外层循环 for (int i = 1; i &lt;= 9; i++) { // 内层循环 for (int j = 1; j &lt;= i; j++) { System.out.print(j + &quot;*&quot; + i + &quot;=&quot; + j * i + &quot;\\t&quot;); } System.out.println(); }} 空心金字塔： 123456789101112131415161718192021222324//分析思路//化繁为简：//1. 先打印一个矩形//2. 打印半个金字塔//3. 打印整个金字塔 （一个循环中嵌套两个循环。先算星星，再算空格）//4. 打印空心金字塔 (第一个位置是*，最后一个位置也是*，最后一层全部是*)//5. 先死后活： 层数作为变量int totalLevel = 54; //层数for (int i = 1; i &lt;= totalLevel; i++) { //i为层数 //再打印星星之前需要打印空格，空格 = 总层数 -当前层 for (int k = 1; k &lt;= totalLevel -i; k++) { System.out.print(&quot; &quot;); } for (int j = 1; j &lt;= 2 * i - 1; j++) { //当前行第一个位置是*，最后一个位置也是*，最后一层全部是* if (j ==1 || j ==2 * i -1 || i == totalLevel) { System.out.print(&quot;*&quot;); } else { //其他情况输出空格 System.out.print(&quot; &quot;); } } System.out.println(); 空心菱形： 1234567891011121314151617181920212223242526272829303132333435363738/*化繁为简1. 打印一个金字塔 (空格个数为总层数-当前层)2. 打印菱形3. 打印空心菱形先死后活设置层数变量 */int n = 4; //层数int totalLevel = n/2;for (int i = 1; i &lt;= totalLevel; i++) { for (int k = 1; k &lt;= totalLevel - i; k++) { System.out.print(&quot; &quot;); } for (int j = 1; j &lt;= i * 2 -1; j++) { if (j == 1 || j == i * 2 - 1) { System.out.print(&quot;*&quot;); } else { System.out.print(&quot; &quot;); } } System.out.println();}for (int i = totalLevel - 1 ; i &gt;= 1; i--) { for (int k = 1; k &lt;= totalLevel - i; k++) { System.out.print(&quot; &quot;); } for (int j = 1; j &lt;= i * 2 -1; j++) { if (j == 1 || j == i * 2 - 1) { System.out.print(&quot;*&quot;); } else { System.out.print(&quot; &quot;); } } System.out.println(); 跳转控制breakbreak 语句可以强制终止所在所在循环，在嵌套循环中，break 仅影响当前所在循环。一个循环中可以不只有一个 break 语句。 break 语句出现在多层嵌套的语句块中，可以通过标签指明要终止的是哪一层语句块。 12345678910lable1:for (int j = 0; j &lt; 4; j++) { lable2: for (int i = 0; i &lt; 10; i++) { if (i == 2) { break; //等价 break label2 } System.out.println(&quot;i = &quot; + i); }} continuecountinue 与 break 的区别在于，countinue 并不是终止整个循环，而是中止最近的一次循环的当次迭代。 注意： continue 语句只能用在 while 语句、for 语句或者 foreach 语句的循环体之中，在这之外的任何地方使用它都会引起语法错误。 终止指的是结束整个循环，中止指的是结束循环的当次迭代（跳过）。 coutinue 语句出现在多层嵌套的语句块中，可以通过标签指明要中止的是哪一层语句块。 1234567891011 label1: for (int j = 0; j &lt; 4; j++) { label2: for (int i = 0; i &lt; 10; i++) { if (i == 2) {// continue; //等价于 coutinue label2 continue label1; } System.out.println(&quot;i = &quot; + i); } } return在方法中，return 表示跳出所在的方法。 注意：如果 return 在 main 中使用，将表示为退出程序。 12345678for (int i = 1; i &lt;= 5; i++) { if (i == 3) { System.out.println(&quot;你好&quot; + i); return; //当使用在方法时。表示跳出方法，如果在main中，表示退出程序 } System.out.println(&quot;Hello World!&quot;);}System.out.println(&quot;go on..&quot;); 第六章 数组、排序和查找数组数组可以存放多个同一类型的数据。数组也是一种数据类型，是引用类型（数组就是一组数据）。 12345678910//定义一个数组double[] hens = {3, 5, 1, 3.4, 2, 50};double sum = 0;//遍历数组得到所有元素的和for (int i = 0; i &lt; 6; i++) { System.out.println(&quot;第 &quot; + (i + 1) + &quot; 个元素的值：&quot; + hens[i]); sum += hens[i];}System.out.println(&quot;所有元素和：&quot; + sum); double[] 表示该数组为 double 类型的数组，数组名 hens。 {3, 5, 1, 3.4, 2, 50}表示该数组的值/元素，依次表示数组的第几个元素。 通过 数组名[下标] 来访问数组的元素，下标从 0 开始编号，第一个元素就是 hens[0]，第二个元素就是 hens[1]，以此类推。 动态初始化： 直接定义数组大小类型。数据类型[] 数组名 = new 数据类型[大小] 12int[] a = new int[3];//int 类型的名为 a 的数组存放了 3 个int类型的数据 先声明数组，再 new 分配空间。 123456//1. 声明数组int[] a;//或 int a[]，此方法不推荐使用//2. 分配空间a = new int[3]; //分配内存空间，可以存放数据 静态初始化数据类型[] 数组名 = {元素值1, 元素值2...} 12double[] hens = {3, 5, 1, 3.4, 2, 50};//注意：仅适用于有指定元素。 数组使用细节： 数组元素可以是任何数据类型，但是不能混用。 数组创建后如果没有赋值，会有默认值，char 为\\u0000，String 为 null，boolean 为 false。 数组属于引用类型，数组型数据是对象（）。 数组赋值机制（重要）： 基本数据类型赋值，这个值就是具体的数据（栈），而且相互不影响。 1int n1 = 2; int n2 = n1; 数组在默认情况下是引用转递，赋的值是地址（堆），实际数据存放在堆中相应地址空间。 12int [] arr1 = {1, 2, 3};int [] arr2 = arr1; 数组赋值手动内容拷贝方式，数据传递，非引用传递。 12345678910//数组内容拷贝，非地址int[] arr1 = {10, 20, 30};//创建一个新的数组arr2，开辟新的数据空间int[] arr2 = new int[arr1.length];//遍历 arr1，把每个元素拷贝到 arr2 对应位置for (int i = 0; i &lt; arr1.length; i++) { arr2[i] = arr1[i];} 数组操作： 翻转 方式一：元素逐个交换 1234567891011//定义数组int[] arr = {11, 22, 33, 44, 55, 66};int temp = 0;//共交换三次for (int i = 0; i &lt; arr.length / 2; i++) { temp = arr[i]; //临时变量保存需要替换的元素 arr[i] = arr[arr.length - i - 1]; arr[arr.length - i - 1] = temp;}System.out.println(Arrays.toString(arr)); 方式二：逆序遍历，赋值新数组 1234567891011//定义数组int[] arr = {11, 22, 33, 44, 55, 66};int[] arr2 = new int[arr.length];int temp = 0;//逆序遍历原数组，再存放入新数组for (int i = arr.length; i &lt;= 0; i--) { arr2[i] = arr[i];}arr = arr2; //arr原空间数据没有被变量引用，jvm自动销毁System.out.println(Arrays.toString(arr)); 扩容 123456789101112131415161718192021222324252627282930int[] arr = {1, 2, 3};Scanner sc = new Scanner(System.in);while (true) { System.out.println(&quot;请输入添加元素值：&quot;); int num = sc.nextInt(); //建立新数组用于存放新添加的元素 int[] arr2 = new int[arr.length + 1]; for (int i = 0; i &lt; arr.length; i++) { arr2[i] = arr[i]; } arr2[arr2.length - 1] = num; arr = arr2; System.out.println(&quot;添加成功！&quot;); System.out.println(Arrays.toString(arr)); //判断是否继续添加 System.out.println(&quot;是否继续添加（y/n）：&quot;); char yes = sc.next().charAt(0); if (yes == 'n') { break; } else if (yes == 'y') { System.out.println(&quot;继续添加！&quot;); } else { System.out.println(&quot;输入有误，退出程序！&quot;); break; }} 缩减 12345678910111213141516171819202122232425262728293031323334int[] arr = {1, 2, 3, 4, 5};Scanner sc = new Scanner(System.in);while (true) { //建立新数组用于存放缩减后的元素 int[] arr2 = new int[arr.length - 1]; for (int i = 0; i &lt; arr.length - 1; i++) { arr2[i] = arr[i]; } arr = arr2; System.out.println(&quot;缩减成功！&quot;); System.out.println(Arrays.toString(arr)); //判断是否能够继续缩减 if (arr.length == 1) { System.out.println(&quot;数组仅剩一位，无法继续缩减！&quot;); break; } //判断是否继续缩减 System.out.println(&quot;是否继续缩减（y/n）：&quot;); char yes = sc.next().charAt(0); if (yes == 'n') { break; } else if (yes == 'y') { System.out.println(&quot;继续缩减！&quot;); } else { System.out.println(&quot;输入有误，退出程序！&quot;); break; }} 排序将多个数据，依照指定的顺序进行排列的过程。 冒泡排序： 1234567891011121314151617int[] arr = {24, 69, 80, 57, 13};int temp = 0;boolean sorted = true;for (int i = 0; i &lt; arr.length - 1; i++) { for (int j = 0; j &lt; arr.length - i - 1; j++) { //如果前面的数大于后面的数，就交换 if (arr[j] &gt; arr[j + 1]) { temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; sorted = false; } } if (sorted) break; //如果某一轮没有交换了，代表已经有序，提前退出程序}System.out.println(Arrays.toString(arr)); 查找顺序查找： 从头到尾一一比对，成功则停止，不成功则继续。 123456789101112131415//定义一个字符串数组String[] names = {&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;dd&quot;};Scanner sc = new Scanner(System.in);System.out.println(&quot;请输入名字：&quot;);String findName = sc.next();//遍历数组，逐一比较for (int i = 0; i &lt; names.length; i++) { if (findName.equals(names[i])) { System.out.println(&quot;找到了！在第 &quot; + (i + 1) + &quot; 位。&quot;); return; //直接退出 }}System.out.println(&quot;没找到！&quot;); 二维数组数组的数组，即二维数组也是一个特殊的一维数组，其每个元素又是一个一维数组。 1数据类型[][] 数组名 = {{元素值1, 元素值2...}, {元素值1, 元素值2...}...} 123456789101112//定义二维数组int[][] arr = {{0, 0, 0, 0, 0, 0}, {0, 0, 1, 0, 0, 0}, {0, 2, 0, 3, 0, 0}, {0, 0, 0, 0, 0, 0}};//输出图形for (int i = 0; i &lt; arr.length; i++) { //遍历二维数组的每个元素（数组） for (int j = 0; j &lt; arr[i].length; j++) { System.out.print(arr[i][j] + &quot; &quot;); } System.out.println(); //换行} 二维数组中访问元素数组的元素：数组名[元素数组下标][元素数组中的元素的下标] 动态初始化： 直接定义数组。 123456789int arr[][] = new int[2][3];arr[1][1] = 7;//遍历for (int i = 0; i &lt; arr.length; i++) { for (int j = 0; j &lt; arr[i].length; j++) { System.out.print(arr[i][j] + &quot; &quot;); } System.out.println(); //换行} 先声明，再 new 分配空间。 1234//1. 声明数组int[][] a; //或者 int[] a[];//2. 分配空间a = new int[3][2]; //分配内存空间，可以存放数据 列数不确定 在多维数组中，列数可以不同。并且通过先声明，再分配空间的方式，有效节约不需要使用的一维数组（列）所占空间大小。 12345678910111213141516171819//有三个一维数组，但每个一维数组还没有开辟空间int[][] arr = new int[3][];for (int i = 0; i &lt; arr.length; i++) { //给每个一维数组开辟空间 //如果没有给一维数组new，那么arr[i]就是null arr[i] = new int[i + 1]; //遍历一维数组，并给元素赋值 for (int j = 0; j &lt; arr[i].length; j++) { arr[i][j] = i + 1; }}//遍历输出for (int i = 0; i &lt; arr.length; i++) { for (int j = 0; j &lt; arr[i].length; j++) { System.out.print(arr[i][j] + &quot; &quot;); } System.out.println(); //换行} 静态初始化 1数据类型[][] 数组名 = {{元素值1, 元素值2...}, {元素值1, 元素值2...}...} 123int[][] arr = {{0, 0, 0, 0, 0, 0}, {0, 0, 1, 0, 0, 0}, {0, 2, 0, 3, 0, 0}, {0, 0, 0, 0, 0, 0}};//注意：仅适用于有指定元素。&gt;) 杨辉三角： 使用二维数组打印一个 10 行的杨辉三角。 12345678910111213141516171819202122232425262728293031323334353637/*11 11 2 11 3 3 11 4 6 4 11 5 10 10 5 11. 第一行有1个元素，第n行有n个元素2. 每一行的第一个元素和最后一个元素都是13. 从第三行开始，对于非第一个元素和最后一个元素的元素的值 arr[i][j] = arr[i-1][j] + arr[i-1][j-1] = 上一行的同一列的数 + 上一行的前一列的数*/int[][] yangHui = new int[10][];for (int i = 0; i &lt; yangHui.length; i++) { //给每个一维数组（行）开辟空间 yangHui[i] = new int[i + 1]; //给每个一维数组（行）赋值 for (int j = 0; j &lt; yangHui[i].length; j++) { //每一行的第一个元素和最后一个元素都是1 if (j == 0 || j == yangHui[i].length - 1) { yangHui[i][j] = 1; } else { //中间的元素 yangHui[i][j] = yangHui[i-1][j] + yangHui[i-1][j-1]; } }}//输出杨辉三角for (int i = 0; i &lt; yangHui.length; i++) { for (int j = 0; j &lt; yangHui[i].length; j++) { System.out.print(yangHui[i][j] + &quot;\\t&quot;); } System.out.println();} 第七章 面向对象（初级）使用传统方式储存物体信息，会有一定问题： 单独定义变量：不利于数据的管理（拆解了信息）。 123456String cat1 = &quot;小白&quot;;String cat2 = &quot;小花&quot;;int age1 = 3;int age2 = 100;String color1 = &quot;白色&quot;;String color2 = &quot;花色&quot;; 使用数组： (1) 数据类型无法定义。(2) 只能通过下标获取信息，造成变量名字和内容的对应关系不明确。(3) 不能体现猫的行为。 12String[] cats1 = {&quot;小白&quot;,&quot;3&quot;,&quot;白色&quot;};String[] cats2 = {&quot;小花&quot;,&quot;100&quot;,&quot;花色&quot;}; 总的来说，就是效率低，不利于管理。因此引出类与对象（OOP）。 类与对象及属性类： 自定义的一种抽象的数据类型（像 int、double 就是系统定义的数据类型）。在类中，我们可以定义属性（name、age、color……）和行为（run、cry、eat……）。 对象： 具体的一个物体（实例），属于某类，而类的这些属性和行为会相应的传递给这个对象。 类是对象的模板，对象是类的一个个体（实例）。 类到对象的说法（通用）： 创建一个对象。 实例化一个对象。 把类实例化。 创建一个猫类，并给它一些属性，再创建两个对象，对其猫类实例化： 12345678910111213141516171819202122232425262728293031323334353637public class Object01 { public static void main(String[] args) { //判断猫 //使用OOP面向对象解决 //实例化一只猫[创建一只猫对象] //第一只猫，catx1就是一个对象 Cat catx1 = new Cat(); catx1.name = &quot;小白&quot;; catx1.age = 3; catx1.color = &quot;白色&quot;; catx1.weight = 20; //第二只猫，catx2也是一个对象 Cat catx2 = new Cat(); catx2.name = &quot;小花&quot;; catx2.age = 100; catx2.color = &quot;花色&quot;; catx2.weight = 20; //访问对象的属性 System.out.println(&quot;第一只猫的信息：&quot; + catx1.name + catx1.color + catx1.age + catx1.weight); System.out.println(&quot;第二只猫的信息：&quot; + catx2.name + catx2.color + catx2.age + catx2.weight); }}//面向对象解决问题//定义一个猫类 Cat =&gt; 自定义的数据类型class Cat { //属性 String name; //名字 int age; //年龄 String color; //颜色 double weight; //体重 //行为} Java 内存的结构： 栈：一般存放基本数据类型（局部变量）。 堆：存放对象（Cat cat，数组等）。 方法区：存放常量池（常量，如字符串）、类加载信息。 对象在内存中的存在形式： 创建对象后，在栈中的对象名称指向一个地址，这个地址在堆中存放了这个对象，其中包含各个地址，这些地址分别指向方法区中常量池里的各个具体的属性值。 需要注意的是，如果对象的属性是基本数据类型（非 String），就直接存放在堆的对象中，而不会指向方法区。 在创建对象的过程中（new），在方法区中会加载该类信息，包含属性信息和方法信息。 属性 / 成员变量细节： 成员变量 = 属性 = field（字段） 属性是类的一个组成部分，一般是基本数据类型，也可以是引用类型（对象、数组）。 属性的定义语法和变量相同：访问修饰符 属性类型 属性名。（访问修饰符用于控制属性的访问范围：public，protected，默认，private，会在认识包后进行系统学习） 属性如果不赋值，会有默认值，规则与数组一致（char 为\\u0000，String 为 null，boolean 为 false）。 对象赋值给对象，也是与数组一致的通过改变地址指向，而非改变内容，因此赋值后两个对象指向同一个地址。 创建对象方式： 先声明，再创建 12Cat cat; //声明对象catcat = new Cat(); //正式创建对象，在内存堆中开辟空间，此时cat指向这个空间 直接创建 1Cat cat = new Cat(); 创建对象流程分析： 加载对象的类信息（属性和方法的信息，且只会加载一次）。 在堆中分配空间，进行默认初始化（属性赋予默认值）。 把堆中的对象的地址赋给栈中的对象名称，此时对象名称指向了相应的对象。 进行指定初始化，如 对象.属性 = XXX 。 成员方法某些情况下，我们需要指定一个对象的行为，即成员方法（简称方法），如人类，除了有属性（年龄、性别等）之外，还会有一些行为。 成员方法使用： 在类中创建方法。 创建对象，调用方法。 1234567891011121314151617181920212223public class Method01 { public static void main(String[] args) { //新建对象 Persons p1 = new Persons(); //调用方法 p1.speak(); }}class Persons { String name; int age; //添加speak成员方法并输出 /* 1. public：表示方法是公开的 2. void：表示方法没有返回值 3. speak()：speak是方法名，()为形参列表 4. {}方法体，可以写要执行的代码 */ public void speak() { System.out.println(&quot;我是一个好人。&quot;); }} 方法可以接收外部信息，经过处理后，可以再传出。 getSum 成员方法，可以计算两个数的和： 123456789// 1. public 表示方法是公开的// 2. int 表示方法执行后，返回一个int值// 3. getSum 方法名// 4. (int num1, int num2) 形参列表，2个形参，可以接收用户传入的数据// 5. return res; 表示把res的值返回public int getSum(int num1, int num2) { int res = num1 + num2; return res;} 调用 getSum 成员方法： 12345//新建对象Persons p1 = new Persons();//调用方法int returnRes = p1.getSum(10,20); //填入需要传入的形参System.out.println(returnRes); 成员方法调用机制： 当程序执行到方法时，就会开辟一个独立的栈空间（还在 main 主方法栈空间内部）。 当方法执行完毕，或者执行到 return 语句时，就会返回到调用方法的地方（main 栈）。 返回后，继续执行犯法后面的代码。 当 main 主方法（栈）执行完毕，程序退出。 使用成员方法的优点： 提高代码复用性。 可以将实现的细节封装，然后供其他用户来调用。 123456789101112131415161718192021222324252627282930313233343536public class Method02 { public static void main(String[] args) { //遍历一个数组，输出数组的各个元素值 int [][] map = {{0,0,1},{1,1,1},{1,1,3}}; //遍历map数组 //传统方式：直接遍历 //缺点：要多次遍历的话，代码冗余度过高，一段代码复制多遍 for (int i = 0; i &lt; map.length; i++) { for (int j = 0; j &lt; map[i].length; j++) { System.out.print(map[i][j] + &quot;\\t&quot;); } System.out.println(); } //方法 //把输出的功能，写到一个类的方法中，直接调用方法 myTools tool = new myTools(); tool.printArr(map); tool.printArr(map); }}class myTools { //方法，接收一个二维数组 public void printArr(int[][] map) { //对传入的map数组进行遍历 System.out.println(&quot;==========&quot;); for (int i = 0; i &lt; map.length; i++) { for (int j = 0; j &lt; map[i].length; j++) { System.out.print(map[i][j] + &quot;\\t&quot;); } System.out.println(); } }} 成员方法的定义： 1234public 返回数据类型 方法名(形参列表...) {//方法体 语句; return 返回值;} 返回数据类型：表示成员方法食醋胡，void 表示没有返回值。 参数列表：表示成员方法输入（如 cal(int n)，n 就是输入的数据）。 方法体：表示为了实现某一功能的代码块。 return 语句不是必须的。 成员方法使用细节： 访问修饰符如果不写则是默认访问，有四种：public, protected, 默认, private。 一个方法最多有一个返回值，可使用数组来解决返回多个值问题。 1234567891011121314151617public class MethodDetail { public static void main(String[] args) { //1. 一个方法最多有一个返回值，如何返回多个结果：数组 AA a = new AA(); int[] res = a.getSumAndSub(1, 4); System.out.println(&quot;和 = &quot; + res[0] + &quot; 差 = &quot; + res[1]); }}class AA { //使用数组作为数据类型 public int[] getSumAndSub(int n1, int n2) { int[] resArr = new int[2]; resArr[0] = n1 + n2; resArr[1] = n1 - n2; return resArr; }} 如果方法要求有返回数据类型，则方法体中的最后的执行语句必须为return 值;，并且要求返回值得类型必须和 return 的值类型一致或兼容。 如果方法是的返回数据类型为 void，则方法体中可以没有 return 语句，或者只写return;。 方法名遵循小驼峰命名法，见名知意，如得到两个数的和则以此命名：getSum。 形参列表使用细节： 一个方法可以有 0 个或多个参数。 参数类型可以为任意类型。 调用带参数的方法时，要对应传入相同或兼容的参数。 方法定义时的参数称为为形式参数（形参），方法调用的时候参数称为实际参数（实参），实参和形参的类型要一致或兼容，个数、顺序必须一致。 方法调用细节： 同一个类中的方法：可以直接在自己的方法体相互去调用。 不同类中的方法：需要通过对象名来调用。 跨类的方法调用和方法的访问修饰符相关，后面细说。 12345678910111213141516171819202122232425262728class A { //同一个类中的方法互相调用：直接调用 public void print(int n) { System.out.println(&quot;print()方法被调用 n=&quot; + n); } public void sayOk() { //sayOk调用 print print(10); //直接调用 System.out.println(&quot;继续执行sayOk()。&quot;); } //不同类中的方法：需要通过对象名来调用 //A类里调用B类的方法 public void m1() { //创建B类的B对象，再调用B对象的方法。 System.out.println(&quot;m1()方法被调用。&quot;); B b = new B(); b.hi(); System.out.println(&quot;m1()方法继续执行。&quot;); }}class B { public void hi() { System.out.println(&quot;B类中的hi()被执行。&quot;); }} 方法传参机制： 基本数据类型：传递的是值（值拷贝，非地址），形参的任何改变都不会影响到实参。 123456789101112131415161718192021222324252627public class MethodParameter01 { public static void main(String[] args) { int a =10; int b =20; //创建AA2对象 AAp obj = new AAp(); obj.swap(a,b); //swap方法将会在栈中新开辟一块独立空间执行方法体语句，和主方法隔离， //因此此时的a和b还是主方法的a和b System.out.println(&quot;主方法 a=&quot; + a + &quot;\\tb=&quot; + b); // a=10 , b=20 }}class AAp { public void swap (int a, int b) { System.out.println(&quot;\\na和b交换前的值 a=&quot; + a + &quot;\\tb=&quot; + b); // a=10, b=20 int tmp = a; a = b; b = tmp; System.out.println(&quot;\\na和b交换后的值 a=&quot; + a + &quot;\\tb=&quot; + b); // a=20, b=10 }} 引用数据类型（数组、对象）：传递的是地址（指向堆中实际的数组空间），形参与实参共享一个地址，可以通过形参影响实参。 12345678910111213141516171819202122232425262728293031323334353637383940414243public class MethodParameter02 { public static void main(String[] args) { B1 b = new B1(); int [] arr = {1, 2, 3}; b.test100(arr); //调用方法 System.out.println(&quot;主方法的arr数组：&quot;); for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i] + &quot;\\t&quot;); } System.out.println(); //换行 //测试 Personx px = new Personx(); px.age = 10; px.name =&quot;jack&quot;; b.test200(px); System.out.println(px.name + px.age); //在方法中修改属性成功 //结论：对象和数组一样是引用类型，栈地址指向堆。 }}class Personx { String name; int age;}class B1 { public void test100(int[] arr) { arr[0] = 200; //遍历数组 System.out.println(&quot;test100的arr数组：&quot;); for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i] + &quot;\\t&quot;); } System.out.println(); //换行 } //在方法中修改对象属性 public void test200(Personx px) { px.age = 10000; //修改对象属性 }} 方法递归韩顺平递归原理讲解 12345678//计算 n 的阶乘public int factorial(int n) { if (n == 1) { return 1; //n为1时停止循环调用 } else { return factorial(n - 1) * n; //n &gt; 1 时自身-1再循环调用factorial方法 }} 递归原则： 执行一个方法时，就会创建一个新的受保护的独立空间（栈空间）。 方法的局部变量是独立的，不会相互影响，如 n 变量。 方法中的引用类型变量（数组，对象）之间会共享该引用类型的数据。 递归必须向退出递归的条件逼近，否则会死循环，无限递归。 当一个方法执行完毕，或者遇到了 return 语句，就会返回，遵循 “谁调用，返回谁” 的原则。 汉诺塔问题： 吐槽一下，韩顺平这里讲的非常简略，压根没讲细节，就光演示了，非常不利于新手理解。 1234567891011121314151617181920212223242526public class HanoiTower { public static void main(String[] args) { Tower tower = new Tower(); tower.move(3, 'A', 'B', 'C'); }}class Tower { //方法 //num 表示要移动的个数，num - 1 表示除去底层一个盘，其他盘的个数 public void move(int num, char a, char b, char c) { if (num == 1) { //只有一个盘的情况，也是最终 System.out.println(a + &quot; =&gt; &quot; + c); } else { //如果有多个盘，可以都分为两个盘，最下面的1盘和上面的num-1盘 // 1. 先借助 c 将上面的 num-1 盘移动到 b。 move(num - 1, a, c, b); // 2. 把最下面的这个1盘，移动到 c。 System.out.println(a + &quot; =&gt; &quot; + c); // 3. 再把暂时放在 b 的 num-1 盘 全部放到 c。 move(num - 1, b, a, c); } }} 如果只要移动一个盘子到 C 上，那么很简单： A =&gt; C 要将两个盘子从 A 放到 C 上，也不难： move(2, A, B, C)A =&gt; B，先把上面的盘子从 A 放到 B。A =&gt; C，再把底层的那个盘子从 A 放到 C。B =&gt; C，最后将临时放在 B 上的盘子放到 C 上。 如此一来两个盘子都在 C 上了。 实现 3 个盘子从 A=&gt;B 的程序执行过程： move(3, A, B, C)move(2, a, c, b)，先把上面的 2 个盘子（即 num - 1 个盘子）从 A 放到 B。A =&gt; C，再把底层的那个盘子从 A 放到 C。move(2, b, a, c)，最后将临时放在 B 上的盘子放到 C 上。 通过对移动三个盘子的过程进行整合，可将多个盘的移动的过程抽象为 1 个盘和 num-1 个盘的移动。 八皇后问题： 递归中的回溯问题。 12345678910111213141516171819202122232425262728293031323334353637383940414243public class QueenTest{ public static void main(String[] args){ Tx t1 = new Tx(); t1.put(0); }}class Tx{ int arr[] = new int[8]; //输出算法 public void print(){ for(int i = 0; i &lt; arr.length; i++){ System.out.print(arr[i] + &quot; &quot;); } System.out.println(); } //判断算法 public boolean judge(int index){ for(int i = 0; i &lt; index; i++){//判断和之前的index个皇后是否冲突 if(arr[i] == arr[index] || Math.abs(arr[index]-arr[i]) == Math.abs(index -i)){ return false; } } return true; //必须放在for循环外部， } //放置算法,即在棋盘中放置第几个皇后 public void put(int index){ //首先判断index是否等于8 if(index == 8){//当index等于8时，即第9个棋子，已经完成了8个棋子的放置 print();//调用输出算法 }else{ for(int i = 0; i &lt; 8; i++){ arr[index] = i;// if(judge(index)){//如果返回true则继续判断 put(index + 1); } } } }} 在最重要的放置算法中，首先判断 index 是否为 8，index 为 8 就代表已经是第 9 颗棋子了，所需要的 8 个皇后已经放置完毕，因此结束当前递归中的此次方法，但不会结束程序，因为方法是递归的，循环嵌套。 例如第一个皇后放置在(0, 0)，下一个皇后会放在(1, X)，再下一个皇后会放在(2, X)，直到第八个皇后放置结束，if(index == 8)判断为 true，结束本次方法。 但注意这个方法是层层递归到第八个皇后的放置的，因此在第八个皇后放置完后，又回到第七个皇后的放置方法中，接着往下看有没有别的地方可以放（即放完第七个皇后别的位置后，再去放第八个皇后，以此往复，检查有无可以放的位置）。 以此类推，第七个皇后能放的位置都放完了，再去检查第六个、第五个……直到第一个皇后也把能放的位置放完了，则完成最后的递归循环，结束程序。 在运行过程中，遇到死棋，也就是中间有皇后已经无法放置了，也会回到上一个递归的方法，即无法放置的皇后的前一个方法，逐个放置不同的位置，再递归到下一个皇后测试，如果一个能放置的位置都没有，那么就会再往前回一个皇后，进行同样操作，直到那个死棋可以放置，以此往复，此为回溯。 其实就是细数每一个位置正确的可能，然后逐个暴力推算破解，不行就润到上一层，行就继续找，找到底再润回上一层找，直到每层都找完了，就结束。 方法重载同一个类中，可以有多个同名方法，但是这些同名方法的形参列表必须不一致。 12345678910public class OverLoad01 { public static void main(String[] args) { //out 对象的 println 方法 //通过同方法的重载，加载不同的形参 System.out.println(100); //int类型 System.out.println(&quot;hello, world&quot;); //字符串类型 System.out.println(1.1); //double类型 System.out.println(true); //boolean类型 }} 如果没有方法的重载，那么光一个 println 方法，需要打印不同的类型的话，岂不是需要 printInt、printChar……这么多个不同名称的方法了。 因此重载的好处有： 减轻了起名的麻烦。 减少了记名的麻烦。 利于接口编程。 通过重载创建四个不同的 calculate 方法： 1234567891011121314151617181920212223class MyCalculator { //四个方法使用了重载技巧 //两个整数的和 public int calculate(int n1, int n2) { return n1 + n2; } //一个整数，一个double的和 public double calculate(int n1, double n2) { return n1 + n2; } //一个double，一个Int的和 public double calculate(double n1, int n2) { return n1 + n2; } //三个Int的和 public int calculate(int n1, int n2, int n3) { return n1 + n2 + n3; }} 调用方法时，只需要填入相应的形参列表，就可以选择对应的方法了。例如调用两个整数的和的方法，只需要calculate(1, 1)，两个参数都为 Int 类型即可。 方法重载使用细节： 方法名称必须相同。 方法形参列表必须不同（形参类型、个数和顺序至少有一样不同，参数名无所谓）。 方法的返回值可以不同。 重载中方法形参类型优先级高于自动类型转换。 1234567public void m(int n) { System.out.println(n * n);}public void m(double n) { System.out.println(n * n);} 如果在调用 m 方法时，输入的形参为 Int 类型，并不会强制转换成 double 类型，而是优先选择能够使用 Int 类型的方法进入。 若只有一个使用 double 类型的方法的形参，那么输入的 Int 类型实参会强制转换为 double 类型带入方法。 可变参数若需要方法名称相同，参数类型相同，但参数个数不同的方法实现同一种功能，如计算 2 个数的和，3 个数的和，4 个数的和…… 的方法，虽可以通过方法的重载来实现，但相对还是比较麻烦。 因此可以使用可变参数来优化，使用一个方法完成不同个数的参数的引用。 可变参数的使用： public 返回类型 方法名(参数类型... 参数名) {} 1234567891011121314151617181920212223public class VarParameter01 { public static void main(String[] args) { HspMethod m = new HspMethod(); m.sum(1, 5, 100); }}class HspMethod { //一个可以计算2个数的和，3个数的和，4个数的和…… 的方法 //可以使用方法重载，但很麻烦 //方法名称相同，功能相同，参数个数不同，使用可变参数优化 // 1. int...表示接收的是可变参数，类型是int，即可以接收多个int // 2. 使用可变参数是时，可以当作数组来使用，即 nums 可以作为数组 public void sum(int... nums) { System.out.println(&quot;接收的参数个数：&quot; + nums.length); int res = 0; for (int i = 0; i &lt; nums.length; i++) { res += nums[i]; } System.out.println(res); }} 在可变参数中，形参列表作为数组引入方法过程，唯一的参数名就是数组名称，数组的内容就是各个参数值。 可变参数使用细节： 可变参数的实参可以为 0 或任意多个。 可变参数的实参可以为数组。 可变参数的本质就是数组 可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数放在最后。 1public void f2(String str, double... nums) {} 一个形参列表中只能出现一个可变参数。 作用域 在 Java 中，主要的变量就是属性（成员变量）和局部变量。 局部变量一般是指在成员方法中定义的变量。 作用域分为全局变量（属性）与局部变量，全局变量顾名思义，作用域整个类中的所有方法，局部变量就是除了属性之外的其他变量，作用域为定义它的代码块。 全局变量（属性）可以不赋值，直接使用，因为会有默认值，但是局部变量必须赋值后才能使用，因为没有默认值。 12345678class T3 { int x2; //全局变量可以不进行初始化 public void test3() { int x = 0; //局部变量必须要初始化 System.out.println(x2); //正常调用 }} 作用域使用细节： 属性和局部变量可以充满，访问时遵循就近原则。 在同一个作用域中（如同一个成员方法中），两个局部变量不能重名。 属性生命周期较长，随着对象的创建而创建，随着对象销毁而销毁。局部变量生命周期焦点，伴随着自身代码块执行而创建，伴随代码块的结束而死亡。 作用域的范围不同，属性可以被本类或其他类通过对象调用。局部变量只能在本类中的对应的方法使用。 全局变量/属性可以加修饰符，局部变量不可以加修饰符。 构造方法/构造器构造器是类的一种特殊的方法，它的主要作用是完成对象的初始化。 123[修饰符] 方法名(形参列表) { 方法体;} 构造器的修饰符可以默认，也可以是 public/protected/private。 构造器没有返回值。 构造器的方法名和类名必须一致。 参数列表与成员方法规则一致。 构造器的调用由系统完成。 1234567891011121314151617181920212223242526public class Constructor01 { public static void main(String[] args) { //当 new 一个新对象时，直接通过构造器指定整个对象的年龄和姓名 Person4 p1 = new Person4(&quot;张三&quot;, 80); System.out.println(&quot;p1对象信息：&quot;); System.out.println(&quot;name = &quot; + p1.name); System.out.println(&quot;age = &quot; + p1.age); }}//构造方法：在创建人类的对象时，就直接指定这个对象的年龄和姓名class Person4 { String name; int age; // 1. 构造器没有返回值，也不能写void // 2. 构造器的名称和类Person4一样 // 3. 构造器形参列表规则与成员方法一样 public Person4(String pName, int pAge) { System.out.println(&quot;构造器被调用，完成对象的初始化。&quot;); name = pName; age = pAge; }} 构造器使用细节： 一个类可以定义多个构造器，即构造器的重载。 12345678910111213141516171819202122public class ConstructorDetail { public static void main(String[] args) { Person5 p1 = new Person5(&quot;king&quot;, 40); Person5 p2 = new Person5(&quot;king&quot;); }}class Person5 { String name; int age; //第一个构造器 public Person5(String pName, int pAge) { name = pName; age = pAge; } //第二个构造器 public Person5(String pName) { name = pName; }} 构造器是完成对象的初始化，并不是创建对象。 在创建对象时，系统自动调用该类的构造方法。 如果程序员未定义构造器，系统会自动给类生成一个默认无参构造器，如Person(){}。 如果自己定义了构造器，默认的无参构造器就被覆盖了，除非显示的定义：Dog(){}。 再次分析对象的创建流程（以 Person 类为例）： 12345678class Person { 类 int age = 90; String name; Person(String n, int a) { //构造器 name = n; //属性赋值 age = a; }} 加载 Person 类信息（Person.class），只会加载一次。 在堆中分配空间（地址）。 完成对象初始化：3.1 默认初始化：age=0 name=null3.2 显式初始化：age=90, name=null3.3 构造器的初始化：age=20, name = “xxx” 把对象在堆中的地址，返回给 p（对象名，实际上是对象的引用）。 this 关键字this 相当于在对象中的一个属性，值为地址，这个地址指向对象本身，因此 this 相当于引用的对象自身。哪个对象调用，this 就代表哪个对象。 HashCode 将对象的实际地址转换成整数并输出，我们可以通过 HashCode 来判断是否为同一个对象地址： 12345678910111213141516171819202122232425262728public class This01 { public static void main(String[] args) { Dog dog1 = new Dog(&quot;大壮&quot;, 3); System.out.println(&quot;dog1的hashCode值：&quot; + dog1.hashCode()); Dog dog2 = new Dog(&quot;大黄&quot;, 2); System.out.println(&quot;dog2的hashCode值：&quot; + dog2.hashCode()); dog1.info(); dog2.info(); }}class Dog { String name; int age; //根据作用域原则，构造器的name就是局部变量，不是属性 public Dog(String name, int age) { //构造器 //this.name 就是当前对象的属性 name this.name = name; //this.age 就是当前对象的属性 age this.age = age; System.out.println(&quot;this的hashCode值：&quot; + this.hashCode()); } public void info() { System.out.println(name + &quot;\\t&quot; + age + &quot;\\t&quot;); //成员方法，输出属性信息 }} 可见两个对象的地址和其 this 的地址输出一致。 this 使用细节： this 可以用来访问本类的属性、方法、构造器。 this 用于区分当前类的属性和局部变量。 访问成员方法的语法：this.方法名(参数列表)。 访问构造器的语法：this(参数列表)（只能在构造器中访问另一个构造器，且必须放在结构体的第一句）。 this 不能在类的外部使用，只能在类定义的方法中使用。 传统方式调用类的成员变量，会遵循就近原则，如果在方法内定义过了和成员变量相同名称的变量，那么只会调用到方法内的变量，而不会是方法外的成员变量。但使用 this 关键字，可以直接访问到方法外部的成员变量。 猜拳游戏： 虽然是简单的 if 语句判断，但是融合了类与对象的知识，将功能模块化分装成方法，是非常好的面对对象实践。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697import java.util.Random;import java.util.Scanner;public class Homework14 { //猜拳 public static void main(String[] args) { caiquan t = new caiquan(); //创建二维数组，记录出拳情况 int[][] arr1 = new int[3][3]; int j = 0; //创建一维数组，记录输赢情况 String[] arr2 = new String[3]; for (int i = 0; i &lt; 3; i++) { //获取玩家出拳 arr1[i][j + 1] = t.getUserG(); //判断输入是否正确 if (arr1[i][j + 1] == -1) { i--; continue; } //获取电脑出拳 arr1[i][j + 2] = t.getComG(); //出拳情况比较 String win = t.vs(); arr2[i] = win; System.out.println(&quot;局数\\t玩家出拳\\t电脑出拳\\t输赢情况&quot;); System.out.println(i + 1 + &quot;\\t&quot; + arr1[i][j + 1] + &quot;\\t&quot; + arr1[i][j + 2] + &quot;\\t&quot; + arr2[i]); System.out.println(&quot;------------------------------&quot;); } //列出结果 System.out.println(&quot;局数\\t玩家出拳\\t电脑出拳\\t输赢情况&quot;); for (int i = 0; i &lt; arr1.length; i++) { System.out.println(i + 1 + &quot;\\t&quot; + arr1[i][j + 1] + &quot;\\t&quot; + arr1[i][j + 2] + &quot;\\t&quot; + arr2[i]); } System.out.println(&quot;总共玩了：&quot; + t.count + &quot;次。&quot;); System.out.println(&quot;总共赢了：&quot; + t.userWin + &quot;次。&quot;); }}class caiquan { //用户出拳，电脑出拳，用户赢次数，总共玩次数 int userG, comG, userWin, count; public int getUserG() { try { Scanner sc = new Scanner(System.in); System.out.println(&quot;请出拳（0-拳头，1-剪刀，2-布）：&quot;); userG = sc.nextInt(); //判断是否输入超值 if (userG &gt;= 0 &amp;&amp; userG &lt;= 2) { return userG; } else { System.out.println(&quot;输入错误，请重试！&quot;); return -1; } } catch (Exception e) { //判断是否输入其他字符 System.out.println(&quot;数字输入错误，请重试！&quot;); return -1; } } //获取电脑出拳 public int getComG() { Random r = new Random(); comG = r.nextInt(3); return comG; } //判断输赢 public String vs() { count++; if (comG == 1 &amp;&amp; userG == 0) { userWin++; return &quot;玩家赢。&quot;; } else if (userG == 1 &amp;&amp; comG == 2) { userWin++; return &quot;玩家赢。&quot;; } else if (userG == 2 &amp;&amp; comG == 0) { userWin++; return &quot;玩家赢。&quot;; } else if (userG == comG) { return &quot;平局&quot;; } else { return &quot;电脑赢。&quot;; } }} 第八章 面向对象（中级）IDEA 使用 快捷键 功能 Ctrl + Alt + L 一键格式化代码 Ctrl + D 复制当前行到下一行 Shift + Enter 新建一行，并且光标移到新行 Ctrl + Y 删除当前行 Alt + Enter 自动导入当前行所需要的类 Alt + R 运行当前程序 Alt + Insert 生成构造方法 Ctrl + H 查看所选类的层级关系 Ctrl + B 定位到所选方法所在位置 方法.var 自动分配变量名 F8 Step Over 跳过当前 Debug 语句 F7 Step Into 跳入当前 Debug 自定义的方法 Alt+ Shift +F7 Force Step Into 强制跳入，可以进入任何方法 Shift + F8 Step Out 跳出当前 Debug 方法 F9 Resume Program 继续执行到下一个断点 包三大作用： 区分相同名字的类。 当类很多时，可以方便的对类进行管理。 控制访问范围。 基本语法：package com.laelwz package 关键字表示打包，com.laelwz表示包名。 原理： 实际上就是创建不同的文件夹来保存类文件，画出示意图。 包的命名： 命名规则：只能包含数字、字母下划线、小圆点.，不能用数字开头，不能是保留字或关键字。 命名规范：小写字母+小圆点，一般为com.公司名.项目名.业务模块名。例如：com.laelwz.oa.model、com.laelwz.oa.controller 常用包： java.lang.* 基本包，默认引入，无需手动引入。 java.util.* 系统提供的默认工具包、工具类（Scanner 之类）。 java.net.* 网络包，网络开发使用。 java.awt.* 界面开发，GUI 使用。 包的引用方法： import 包; 1234//引用某个包下的某个类import java.util.Arrays; //只引入java.util包下的Arrays类//引用整个包import java.util.*; //将java.util包所有类都引入 包使用细节： package的作用是声明当前类所在的包，需要放在类的最上面，一个类最多只有一句。 import放在package之后，在类定义之前，可以有多句，没有顺序要求。 访问修饰符Java 提供四种访问控制修饰符号，用于控制方法和属性（成员变量）的访问权限（范围）： 公开：public 修饰，对外公开。 受保护：protectd 修饰，对子类和同一个包中的类公开。 默认：没有修饰，只向同一个包的类公开。 私有：private 修饰，只有类本身可以访问，不对外公开。 访问级别 修饰符 同类 同包 子类 不同包 公开 public √ √ √ √ 受保护 protected √ √ √ X 默认 没有修饰符 √ √ X X 私有 private √ X X X 访问修饰符使用细节： 修饰符可以用来修饰类中的属性、成员方法以及类。 类只有默认与 public 修饰符。 成员方法的访问规则和属性完全一致。 OOP 三大特征封装把抽象出的数据（属性）和对数据的操作（方法）封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作（方法），才能对数据进行操作。 封装的作用： 隐藏实现细节：调用方法，只要求传入参数，返回结果。 可以对数据进行验证，保证安全。 封装的使用： 将属性私有化（private），意味着不能直接在外部直接修改属性。 提供一个公共的 set 方法，用于属性的判断与赋值。 1234public void setXxx(类型 参数名) { //数据验证 属性 = 参数名；} 提供一个公共的 get 方法，用于获取属性的值。 1234public 属性类型 getXxx() { //权限判断 return 属性值;} 例：对工人类属性、方法进行封装处理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.laelwz.encap;public class Encapsulation01 { public static void main(String[] args) { Person person = new Person(); person.setName(&quot;asd&quot;); //设置名字并验证 person.setAge(30); //设置年龄并验证 person.setSalary(30000); //设置薪水 System.out.println(person.info()); //输出工人信息方法 System.out.println(person.getSalary()); //输出获取薪水信息方法 }}class Person { public String name = &quot;无名人&quot;; //名字公开 private int age; //年龄私有 private int salary; //工资私有 //手写get/set太慢，可以使用快捷键 //根据要求完善代码 public String getName() { return name; } public void setName(String name) { //加入对数据的校验,相当于加入了业务逻辑 if (name.length() &gt;= 2 &amp;&amp; name.length() &lt;= 6) { this.name =name; } else { System.out.println(&quot;名字长度错误，需要2-6字符，设置默认名字：无名人&quot;); this.name = &quot;无名人&quot;; } } public int getAge() { return age; } public void setAge(int age) { //判断 if (age &gt;= 1 &amp;&amp; age &lt;= 120) { this.age = age; } else { System.out.println(&quot;年龄错误，需要 1-120，设置默认年龄为18&quot;); this.age = 18; //默认年龄 } } public int getSalary() { return salary; } public void setSalary(int salary) { this.salary = salary; } //写一个方法，返回属性 public String info() { return &quot;信息为 name=&quot; + name + &quot; age=&quot; + age + &quot; salary=&quot; + salary; }} 将构造器与 setXxx 结合： 若需要在构造器中对输入的属性进行验证，可直接在构造器中执行 setXxx 方法进行属性设置。 123456789101112//三个属性的构造器public Person(String name, int age, int salary) { //传统方法// this.name = name;// this.age = age;// this.salary = salary; //可以将setXxx方法写在构造器中，这样仍然可以进行数据的验证 setName(name); setAge(age); setSalary(salary);} 继承当多个类存在相同的属性和方法，会导致代码的冗余，这时可以使用继承的方法来提高代码效率。 通过继承，从这些相似的类中抽象出父类（基类/超类），在父类中定义这些相同的属性和方法，子类就可以直接继承到父类的这些属性和方法，而不需要每个子类都再重新定义一遍。 基本语法： 123class 子类 extends 父类 {} 继承的优点： 代码复用性提高。 代码的扩展性和可维护性提高。 继承使用细节： 子类能够继承父类所有属性和方法，但是父类的私有属性不能在子类直接访问，需要通过父类提供的公共方法间接访问。例如用一个公共 public 权限的方法去返回一个私有 private 权限的属性。 子类必须调用父类的构造器，完成父类的初始化。（ 默认执行super()方法，会自动调用父类的无参构造器） 当创建子类对象时，无论使用子类的任何构造器，都会默认去调用父类的无参构造器（无参构造器默认存在），如果父类没有提供无参构造器，则必须在子类的构造器中使用super()方法去指定使用父类的任意构造器，以此完成父类的初始化工作，否则无法通过编译。 指定调用父类的某个构造器，只需要显式的使用super(参数列表)调用即可，这里的 super 就是指向父类的构造器。 super()方法必须放在构造器的第一行，且只能在构造器中使用。 super 与 this 在构造器中只能二选一，不可同时出现。 Java 中所有类都是 Object 类的子类，Object 是所有类的基类。 父类构造器的调用不限于上一级父类，会一层一层追溯到最顶层的 Object 类，每个父类的构造器都会被调用。 子类最多只能继承一个父类（直接继承），即单继承机制。 不可滥用继承，子类和父类之间必须满足 is-a 的逻辑关系 12Xiaoming is a Person =&gt; Xiaoming extends PersonCat is a Animal =&gt; Cat extends Animal 继承在内存中的分析： 当一个对象创建，首先从该对象的类的最顶层父类 Obeject 开始逐一加载父类与子类，这些类信息都加载在内存方法区中。 在堆中开辟一个属于该对象的内存空间。 在该空间内，根据父类子类的顺序从父到子依次写入每个类的属性、方法（基本数据类型直接写入数据，String 类型与方法则写入地址，实际数据储存到方法区的常量池中），每个类都拥有一个区块（避免重名问题）。 最后将该对象的内存空间地址返回到（指向）主方法中的对象名称。 对象属性在各级类之间的查找关系： 123456789101112131415161718192021222324252627282930313233package com.laelwz.extend_;public class ExtendsTheory { public static void main(String[] args) { Son son = new Son(); //属性查找关系 /* 1. 首先看子类是否有该属性 2. 如果有并且可以访问，则返回信息 3. 如果子类没有这个属性，则向父类查找该属性，如果有则返回 4. 如果父类没有，则继续像上级类逐级查找，直到Object基类 */ System.out.println(son.name); System.out.println(son.age); System.out.println(son.hobby); }}class GranPa { //爷类 String name = &quot;大头爷爷&quot;; String hobby = &quot;旅游&quot;;}class Father extends GranPa { //父类 String name = &quot;大头爸爸&quot;;// String hobby = &quot;钓鱼&quot;; int age = 23;}class Son extends Father { //子类 String name = &quot;大头儿子&quot;;// String hobby = &quot;学习&quot;;} 继承设计的基本思想： 父类的构造器完成父类属性初始化，子类的构造器完成子类属性初始化。 12345678910package com.laelwz.extend_.exercise;public class PC extends Computer { private String brand; public PC(String cpu, int memory, int disk, String brand) { super(cpu, memory, disk); //先初始化父类的构造器 this.brand = brand; //再初始化子类（自身） }} 多态若有同一种行为，但是目标和对象很多而且不同，那么按照传统写法，势必要写多个方法，如 123456789101112//主人给狗喂食骨头public void feed(Dog dog, Bone bone) { System.out.println(&quot;主人&quot; + name + &quot;给&quot; + dog.getName() + &quot;吃&quot; + bone.getName());}//方法的重载//主人给猫喂黄花鱼public void feed(Cat cat,Fish fish) { System.out.println(&quot;主人&quot; + name + &quot;给&quot; + cat.getName() + &quot;吃&quot; + fish.getName());}//如果动物和食物很多 =&gt; 方法很多，复用性不高，不利于管理和维护 ^2394bc 很明显的，这样带来了问题：方法很多，复用性不高，不利于管理和维护。因此引出多态的方法来进一步解决代码复用性不高的问题。 多态是指方法或对象具有多种形态，其建立在封装和继承的基础之上。 方法重载体现多态：传入不同参数，就调用不同方法。 方法重写体现多态：同名不同类，调用不同方法。 对象体现多态： 一个对象的编译类型和运行类型可以不一致，即可以让父类的引用名称，指向子类的对象。 编译类型在定义对象时就确定了，不可改变。 运行类型是可以变化的。 123456//Animal就是编译类型，Dog()、Cat()就是运行类型Animal dog = new Dog();Animal cat = new Cat();//运行类型是可以改变的。dog = new Cat(); //dog的运行类型由Dog变成了Cat，但编译类型仍为Animal 因此使用多态机制，可以较为方便的解决开篇的复用问题： 1234//使用多态机制，可以统一的管理主人喂食的问题public void feed(Animal animal, Food food) { System.out.println(&quot;主人&quot; + name + &quot;给&quot; + animal.getName() + &quot;吃&quot; + food.getName());} 多态的转型： 前提：两个对象（类）存在继承关系。 (1) 向上转型：父类类型 引用名 = new 子类类型(); 本质：父类引用指向了子类的对象。 在使用时可以调用父类中的所有方法（遵循访问权限），但不能调用子类的特有方法（即重写方法以外的那些方法）。 向上转型时，按照从子类（运行类型）开始查找方法，没有找到则到上一级父类查找方法，先子后父，与方法调用规则一致。 (2) 向下转型：子类类型 引用名 = (子类类型) 父类引用; 本质：子类引用指向了父类的对象。 只能强转父类的引用（相当于一个名称，绑定了内存中对象的地址），不能强转父类的对象（对象已经是在内存中）。 可以要求父类引用必须指向的是当前目标类型的对象。 123Animal animal = new Cat(); //向上转型 √Cat cat = (Cat) animal; //向下转型 √Dog dog = (Dog) animal; //错误的向下转型 √ 当向下转型后，可以调用子类类型中的所有成员。 多态的使用细节： 属性没有重写之说，属性的值看编译类型。 12345678910111213141516public class PolyDetail02 { public static void main(String[] args) { Base base = new Sub(); //编译类型为Base System.out.println(base.count); //输出的值为Base类中的10 }}class Base { //父类 int count = 10;}class Sub extends Base { //子类 int count = 20;} instanceOf 比较操作符，用于判断对象的运行类型是否为 XX 类型或 XX 类型的子类型。 12345678910111213141516171819202122232425public class PolyDetail03 { public static void main(String[] args) { BB bb = new BB(); System.out.println(bb instanceof BB); //true System.out.println(bb instanceof AA); //true //aa 编译类型为 AA，运行类型为 BB AA aa = new BB(); System.out.println(aa instanceof AA); //true System.out.println(aa instanceof BB); //true Object obj = new Object(); System.out.println(obj instanceof AA); //false String str = &quot;Hello&quot;;// System.out.println(str instanceof AA); System.out.println(str instanceof Object); //true }}class AA {}class BB extends AA {} 动态绑定机制：当调用对象方法的时候，该方法会和对象的内存地址/运行类型绑定，优先调用其绑定的类型中的方法。（属性没有动态绑定机制，哪里声明，哪里使用） 多态的具体应用： 多态数组 将数组的定义类型为父类类型，而数组内保存的实际元素类型为子类类型。 123456Person[] persons = new Person[5];persons[0] = new Person(&quot;jack&quot;, 20);persons[1] = new Student(&quot;mary&quot;, 18,100);persons[2] = new Student(&quot;smith&quot;, 19, 30);persons[3] = new Teacher(&quot;scott&quot;, 30, 20000);persons[4] = new Teacher(&quot;king&quot;, 50, 25000); persons 数组为 Person[] 类型，而其元素为 Person 类型的子类对象。 若想再多态数组的子类对象中调用其特有方法，则需要将该子类元素对象向下转型： 1234567891011121314151617181920//循环遍历多态数组，调用sayfor (int i = 0; i &lt; persons.length; i++) { //person[i]编译类型是Person，巡行类型是根据实际情况JVM判断 //动态绑定， System.out.println(persons[i].say()); //想要运行子类的特定方法，必须向下转型 if (persons[i] instanceof Student) { //判断person[i]的运行类型是否为 学生 Student student = (Student) persons[i]; //向下转型 student.study(); } else if (persons[i] instanceof Teacher) { Teacher teacher = (Teacher) persons[i]; //向下转型 teacher.teach(); } else if (persons[i] instanceof Person) { //不做处理 } else { System.out.println(&quot;类型有误，请检查。&quot;); }} 多态参数 方法定义的形参类型为父类类型，实参类型允许为子类类型。 12345678//调用子类方法public void testWork(Employee e) { //形参为父类类型 if (e instanceof Worker) { //判断实参是否为工人类 ((Worker) e).work(); //向下转型 } else if (e instanceof Manager) { //判断实参是否为管理类 ((Manager) e).mange(); //向下转型 }} super 关键字super 代表父类的引用，用于访问父类的属性、方法、构造器。 super 的优点： 调用父类构造器，分工明确，父类属性由父类初始化，子类属性由子类初始化 当子类中由父类的成员（属性和方法）重名时，为了访问父类的成员，必须通过 super。若没有重名，使用 super/this/直接访问 是一样的效果。 super 与 this、直接访问的区别解析： 寻找普通方法/属性时，先找本类，再找父类，没有再找父类的父类，直到 Object 类 使用 this 时，普通方法规则一致。 使用 super 时，直接跳过本类，其他与普通方法规则一致 如果在查找方法时找到了但不能访问（权限不够）则报错，没找到则提示方法不存在。 super 的访问不限于直接父类，如果和多个上级类都有同名成员，则遵循就近原则。 区别 this super 属性 访问本类属性，如果没有则从父类中查找。 直接访问父类中的属性。 方法 访问本类方法，如果没有则从父类中查找。 直接访问父类中的方法。 构造器 调用本类构造器，且只能放在构造器的首行。 调用父类构造器，且必须放在子类构造器的首行。 意义 表示当前对象。 表示父类对象。 override 方法重写当子类有一个方法与父类（或更高级）的某个方法名称、返回类型、形参列表相同，那么就称子类的这个方法覆盖了父类的方法。即外壳不变，核心重写。 方法重写使用细节： 子类的方法的形参列表、方法名称要和父类方法的形参列表、方法名称完全相同。 子类的返回类型要和父类返回类型相同，或者是父类返回类型的子类，如父类返回类型为 Object，子类返回类型为 String。 子类方法不能缩小父类方法的访问权限，但是可以扩大。 方法重载和重写的比较： 名称 发生范围 方法名 参数列表 返回类型 修饰符 重载 overload 本类 必须一样 类型、个数和顺序至少有一个不同 无要求 无要求 重写 override 父子类 必须一样 相同 子类重写的方法，返回的类型和父类返回的类型须一致，或者是其返回类型的子类 子类方法不能缩小父类方法的访问范围，但是可以扩大 Object 类equals()== 与 equals 的对比， == 是一个比较运算符： 既可以判断基本类型，也可以判断引用类型。 如果判断基本类型，判断的是值是否相等。 如果判断引用类型，判断的是地址是否相等（即判定是否是同一个对象）。 123456789101112131415161718192021222324252627package com.laelwz.Object_;public class Equals01 { public static void main(String[] args) { A a = new A(); A b = a; A c = b; System.out.println(a == c); //true System.out.println(b == c); //true B bObjc = a; //指向同一个对象空间，equals就认为相同 System.out.println(bObjc == c); //true int num1 = 10; double num2 = 10.0; System.out.println(num1 == num2); //true 基本数据类型，判断值是否相同 }}class B {}class A extends B {} equals 是 Object 类中的方法： 只能判断引用类型（如 String）。 默认判断地址是否相等，但子类中往往重写该方法，用于判断内容是否相等（如 Integer 类型和 String 类型中）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051System.out.println(&quot;Object的equals：&quot;);Object Obj1 = new Object();Object Obj2 = new Object();System.out.println(Obj1 == Obj2); //false 对象地址不同System.out.println(Obj1.equals(Obj2)); //false Object的equals默认也只判断地址/*Object的equals方法源码，只判断是否地址相同public boolean equals(Object obj) {return (this == obj);} */System.out.println(&quot;String的equals：&quot;);String str1 = new String(&quot;哈哈&quot;);String str2 = new String(&quot;哈哈&quot;);System.out.println(str1 == str2); //false 对象地址不同System.out.println(str1.equals(str2)); //true 内容相同/*String的equals方法源码，String继承于Object，重写了Object的equals方法，用于判断字符串的值是否相等public boolean equals(Object anObject) {if (this == anObject) { //如果是同一个对象 return true; //返回true}if (anObject instanceof String) { //判断类型是不是String String aString = (String)anObject; //向下转型 if (coder() == aString.coder()) { return isLatin1() ? StringLatin1.equals(value, aString.value) : StringUTF16.equals(value, aString.value); }}return false;} */Integer integer1 = new Integer(6);Integer integer2 = new Integer(6);System.out.println(&quot;Integer的equals：&quot;);System.out.println(integer1 == integer2); //false 对象地址不同System.out.println(integer1.equals(integer2)); //true 值相同/*Integer也重写了Object的equals方法变为判断两个值是否相同public boolean equals(Object obj) {if (obj instanceof Integer) { return value == ((Integer)obj).intValue();}return false;} */ 重写 equals 方法实例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.laelwz.Object_;public class EqualsExercise01 { public static void main(String[] args) { Person person1 = new Person(&quot;jack&quot;, 10, '男'); Person person2 = new Person(&quot;jack&quot;, 10, '男'); //默认为假，继承Object的equals方法，值判断地址是否相等 System.out.println(person1.equals(person2)); }}class Person{ private String name; private int age; private char gender; //重写Object的equals方法 public boolean equals(Object obj) { //判断如果比较的两个对象是同一个对象，则直接返回true if (this == obj) { return true; } //类型判断 if (obj instanceof Person) { //是Person，我们才比较 //进行向下转型，因为需要得到obj的各个特有属性 Person p = (Person) obj; //返回各个属性的比较结果，各个属性的内容一致则返回true return this.name.equals(p.name) &amp;&amp; this.age == p.age &amp;&amp; this.gender == p.gender; } //如果不是Person，则直接返回false return false; } public Person(String name, int age, char gender) { this.name = name; this.age = age; this.gender = gender; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public char getGender() { return gender; } public void setGender(char gender) { this.gender = gender; }} hashCode() hashCode() 方法能够提高具有哈希结构的容器的效率。 如果多个引用指向同一个对象，则其哈希值一定一致。 如果多个引用指向不同对象，则哈希值不同。 哈希值是基于地址来编写的，但不等价于地址。 如果需要，则可以重写 hashCode() 方法。 1234567891011121314package com.laelwz.Object_;public class HashCode_ { public static void main(String[] args) { AA aa1 = new AA(); AA aa2 = new AA(); AA aa3 = aa1; System.out.println(aa1.hashCode()); System.out.println(aa2.hashCode()); System.out.println(aa3.hashCode()); }}class AA{} toString() toString()方法默认返回 全类名+@+哈希值的十六进制。 1234567//Object的toString()源码//1. getClass().getName() 类的全类名(包名+类名)//2. Integer.toHexString(hashCode()) 将对象的hashCode值转换为16进制字符串public String toString() { return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());} 子类往往重写 toString()方法，用于返回对象的属性信息。 12345678@Overridepublic String toString() { //重写后，一般是把对象的属性值输出。 return &quot;Monster{&quot; + &quot;name='&quot; + name + '\\'' + &quot;, job='&quot; + job + '\\'' + &quot;, sal=&quot; + sal + '}';} 当直接输出一个对象时，toString 方法默认调用。 1234Monster monster = new Monster(&quot;小妖怪&quot;, &quot;巡山&quot;, 1000);//两行输出等价System.out.println(monster.toString());System.out.println(monster); finalize() 当对象被回收时，系统自动调用该对象的 finalize 方法。子类可以重写该方法，做一些释放资源的操作。 回收的前提：对象没有任何引用，jvm 认为这是一个垃圾对象，就会调用垃圾回收机制来销毁该对象，在销毁前，会先调用 finalize 方法。 垃圾回收机制的调用是由系统决定的，也可以通过 System.gc() 主动出发垃圾回收机制。 Java18 中已彻底弃用，该方法仅作了解。 Debug 断点调试断点调试是指在程序的某一行设置一个断点，调试时运行到这一行就会停住，然后可以一步一步往下调试，过程中可以看到各个变量当前值，出错的话就会显示错误并停在错误行。 在实际开发中，可以使用断点调试功能来一步一步的查看源码执行过程，从而发现问题所在。 也可以通过断点调试来查看 java 底层源代码的执行过程，提升水平。 注意： 断点调试过程中是运行状态，是以对象的运行类型来执行的。 Debug 快捷键参见 IDEA 使用。","link":"/posts/45350/"},{"title":"MATLAB聚类评价指标计算","text":"发现网上很少关于MATLAB聚类评价指标如CHI、DBI以及轮廓系数的计算，其实使用一个内置函数就搞定了，但是看到很多人在重复造轮子。 evalclusters()函数用法： eva= evalclusters(data,clust,'xxx'); data：不带标签的原始数据。clust：聚类后的标签，参数可以是字符串或者矩阵，字符串了话就要写matlab规定的聚类算法，比如’kmeans’。如果你用的不是matlab自带的聚类算法去聚类的，而是想评估自己写的聚类算法性能，那么clust就填写你聚类结果的标签矩阵 Label (标签) 就行了，比如你的数据data是NM的，N是样本个数，M是特征维数。那么标签矩阵 Label (标签) 就是N1的矩阵，代表聚类后每个样本的标签，这样就可以输出评估结果了。‘xxx’：可以选择四种评价指标：’CalinskiHarabasz’ | ‘DaviesBouldin’ | ‘ gap (差距) ’ | ‘silhouette’‘CalinskiHarabasz’: Calinski-Harabasz index (指数) (CHI，越大越好)‘DaviesBouldin’: Davies-Bouldin index (指数) (用的最多，越小越好)‘ gap (差距) ’: gap (差距) statistic (统计) (越大越好)‘silhouette’: silhouette coefficient (SC，轮廓系数，越大越好) MATLAB代码附件一.xlsx 代码12345678910111213141516171819202122232425clearclc% kmeans聚类中有效性评价指标测试% 问题一Data = xlsread('附件1.xlsx');% 数据标准化处理Data1 = Data(2:426,2:3349);% 建立空数组arzs = zscore(Data1);% 使用kmeans聚类函数[ind,C]=kmeans(arzs,4);data = Data1;label = ind; % 真实标签eva_DBI_1= evalclusters(data,label,'DaviesBouldin');eva_SC_1= evalclusters(data,label,'silhouette');eva_CHI_1= evalclusters(data,label,'CalinskiHarabasz');% 这三个变量即为结果DBI_1 = eva_DBI_1.CriterionValues; % 越小越好SC_1 = eva_SC_1.CriterionValues; % 越大越好CHI_1 = eva_CHI_1.CriterionValues; % 越大越好 运行结果123DBI_1 = 0.614370044401414; % 越小越好SC_1 = 0.724336668984950; % 越大越好CHI_1 = 1.298586390458516e+03; % 越大越好 参考 https://www.mathworks.com/help/stats/evalclusters.html https://www.cnblogs.com/kailugaji/p/16169796.html","link":"/posts/302112/"},{"title":"MySQL学习笔记","text":"期末了，梳理一遍MySQL，防止挂科。 数据库的管理数据库的创建例：创建一个名称为mysqltest的数据库 1create database if not exists mysqltest; 例：创建教务管理数据库teaching，并指定字符集为gb2312，校对原则为gb2312_chinese_ci。 123create database teaching default character set gb2312default collate gb2312_chinese_ci; 打开并设置数据库例：打开前面创建的teaching数据库，设置其为当前默认的数据库 1use teaching; 修改数据库参数例：将前面创建的teaching的默认字符集设置为UTF8，校对规则为utf8_unicode_ci 123alter database teachingdefault character set utf8default collate utf8_unicode_ci; 查看字符集与校对规则12show variables like ‘char%’;show variables like ‘collation_%; 显示数据库结构1show create database teaching; 删除数据库例：删除前面创建的teaching数据库 1drop database teaching; 数据表的管理数据表的创建例：创建学生成绩管理系统数据库中的学生表： 1234567create table student ( studentno char(8), name varchar(10), sex enum('男','女'), birthday date, classno char(7)); 数据表的修改添加列（字段）123alter table 表名add 新列名 数据类型[约束条件] [ first | after 已存在列名]; 例：在student表中添加一个电话字段（tel），将其放到sex字段之后： 12alter table student add tel char(11) after sex; 修改列例：修改student表中的tel字段的列名为Email，数据类型为varchar(30); 1alter table student change tel Email varchar(30); 删除列例：删除student表中的Email列; 1alter table student drop Email; 修改表名称例：将student表重命名为stu: 1alter table student rename to stu; 修改列的数据类型和位置例：修改student表中的Email字段的数据类型为varchar(20)，将其移动到birthday字段之后; 12alter table student modify Email varchar(20) after birthday; 删除表例：删除stu表; 1drop table stu; 插入数据例：给教师表添加两条记录(‘T01’,‘张三’和‘T02’,‘李四’) 1234insert into teacher(teacherno,name) values ('T01','张三');insert into teacher values('T02','李四');- 或insert into teacher values(‘T01’,‘张三’),('T02','李四'); 例：利用set子句向teacher表插入数据 1insert into teacher set name='王五', teacherno='T03'; 修改数据例：给将学号为61130702的学生姓名修改为孙乐然 1update student set name='孙乐然' where studentno='61130702'; 删除数据例：将成绩表中C02成绩最低的1个学生的信息删除 12delete from score where courseno='C02'order by finalscore limit 1; 例：清除成绩表中的所有信息 1delete from score; 表约束 非空约束 null：字段值可以为空 not null：字段值不允许为空 例：创建教师表，设置教师编号为非空约束 1234create table teacher(teacherno char(3) not null,name varchar(10)); 例：修改教师表，设置姓名列为非空约束 1alter table teacher modify name varchar(10) not null 例：修改教师表，去除姓名列的非空约束 1alter table teacher modify name varchar(10); 主键约束 主键列的数据唯一，不允许为空，主键唯一标识表中一条记录。 一张表中最多一个主键约束。 主键可以是一个字段，也可以是多个字段。 例：创建教师表，设置教师编号为主键约束 1234create table teacher( teacherno char(3) primary key, name varchar(10)); 例：修改教师表，去除主键约束 1alter table teacher drop primary key; 例：修改教师表，设置教师编号列为主键约束 1alter table teacher modify teacherno char(3) primary key; 唯一约束 该列唯一，允许为空 一个数据表只能创建一个主键，但可以有多个唯一约束 例：创建教师表，设置教师编号为唯一约束 1234create table teacher( teacherno char(3) unique, name varchar(10)); 例：修改教师表，去除唯一约束 1alter table teacher drop index teacherno; 例：修改教师表，设置教师编号列为唯一约束 1alter table teacher modify teacherno char(3) unique; 默认约束 指定某列的默认值 例：创建学生表student，设置性别的默认约束为男 1234567create table student( studentno char(8), name varcahr(10), sex enum('男', '女') default '男', brithday date, classNo char(7)); 例：删除学生表的默认约束 1alter table student modify sex enum('男'， '女'); 例：对学生表student的sex列，修改默认约束为男 1alter table student modify sex enum('男', '女') default '男'; 外键约束 建立子表与父表的关联，保证数据一致性，父表中信息更新，子表中对应的信息相应改变。 原则：必须依赖于已存在的父表的主键 外键可以为空值 例：创建班级表，表中的teacherno字段为外键（主表是teacher表） 1234567create table class ( classno char(7) primary key, name varchar(20), teacherno char(3), foreign key(teacherno) references teacher(teacherno)); 例：删除班级表teacherno字段上的外键约束 1alter table class drop foreign key teacherno; 例：在班级表的teacherno字段上添加外键约束 1alter table class add foreign key (teacherno) references teacher(teacherno); 检查约束 限定列的数据值范围 例：创建成绩表，设置成绩字段的取值范围是0～100 123456create table score( courseno char(3), studentno char(8), finalscore tinyint default 0 check(finalscore &gt;= 0 &amp;&amp; score &lt;= 100)); 例：删除成绩表上的检查约束 1alter table score drop check score_chk_1; 例：在成绩表的成绩字段添加检查约束（&gt;=0） 1alter table score add check(finalscore &gt;= 0); 简单查询distinct 消除重复行 distinct子句可以消除查询结果中的重复行 例：查找所有参加考试的同学的学号，重复的行只出现一次 1select distinct stuno from tbl_score; where in 判断过滤 where设置了查询条件 in关键字可以判断某个字段的值是否在集合中 查询不在集合中使用not in 多个判断条件使用and连接 例：查询学号为60115101,60115102,60115103,60115104四位同学的成绩 12select * from tbl_score where stuno in(60115101,60115102,60115103,60115104) between and 指定查询范围 排除范围使用not between 例：查询成绩在80—90之间的学号、课程号、成绩 1select * from tbl_score where score between 80 and 90; like 通配符查询 like关键字结合通配符，通过字符串比较来选择符合条件的行 “%” 表示0个或多个字符 “_”表示匹配一个字符 is null 查询空值 查询非空值用 is not null 例：查找成绩表中没有成绩（即成绩为空）的行 1select * from tbl_score where score is null; 聚合函数查询count() count(列名)函数返回非null行的行数 count(*)返回包含null的所有行 sum() 求出某个字段的和 avg() 求出某个字段的平均值 round() 四舍五入 第一个参数是原来的值 第二个参数是小数位数 例：查询每位同学的总分和平均分（四舍五入到1位小数） 1234select stuno, sum(score) as total_score, round(avg(score), 1)from tbl_score group by stuno; max() min() 返回最大值和最小值 查询中的子句order by 对查询结果进行排序 升序：asc，降序：desc 默认升序，null值排最前面，降序则null值排最后 例：查询成绩表中C01课程的成绩，并按成绩降序排列 1select * from tbl_score where courseno='C01' order by score desc; group by 将查询结果按指定字段进行分组 group by与group_concat()函数结合，可以将 每个组中的所有字段值都显示出来 group_concat()的作用是链接字符串 例：使用 GROUP BY 语句 将数据表按名字进行分组，并统计每个人有多少条记录 1select name, count(*) from employee_tbl group by name; with rollup 在分组统计的基础上再进行相同的总体统计 要和group by一起使用，加在最后 having 通常与group by子句结合使用 指定在where子句的筛选后进一步筛选，即group by分组后的再筛选 例：查询选课有2门以上且课程成绩均高于80分的学生的学号及其总成绩（不计算80分以下的），结果按成绩降序排列 123456select stuno as '学号', sum(score) as '总分' from tbl_score where score &gt;= 80 group by stuno having count(*) &gt;= 2 order by sum(score) desc; limit 显示指定序号记录的结果 第一条记录编号为0 第一个参数为开始编号 第二个参数为记录的个数 例：查询成绩表信息，按成绩降序排序，显示前3条记录 1select * from score order by finalscore desc limit 3; 例：查询成绩表信息，按成绩降序排序，显示编号2开始的3条记录 1select * from score order by finalscore desc limit 2,3; 内连接 自然连接运算 为了区分两个表中同名的列，需要对同名的列加上表名做为前缀。 多表（两张以上）查询：先进行两表连接，结果再和第三张表进行连接 例：查询学生的学号、姓名、课程号和成绩。 123select score.stuno, stuname, courseno, score from tbl_score score inner join tbl_student student on student.stuno=score.stuno; 左/右 外连接 左连接 将左表所有值对应右表查询，右表中没有的显示为null 例：查询所有学生的学号、姓名、班级号、班级名称。 123select stuno, stuname, c.classno, classname from tbl_student as s left join tbl_class as c on s.classno=c.classno; 右连接 将右表所有值对应右表查询，左表中没有的显示为null 123select stuno, stuname, c.classno, classname from tbl_student as s right join tbl_class as c on s.classno=c.classno; 合并多个查询结果例：合并姓张和姓李的同学的查询结果 123select * from tbl_student where stuname like '张% ' unionselect * from tbl_student where stuname like '李%'; exists() 在where后用于判断是否存在 返回True或False 例：查询是否存在班级号为‘P601119’的学生，如果存在输出学生信息 12select * from tbl_student where exists(select * from tbl_student where classno='P601119'); 视图例：创建视图course_avg，统计各门课程平均成绩，并按课程名称降序排列 123456create view course_avg as select tbl_course.coursename as 课程名, avg(score) as 平均成绩 from tbl_score inner join tbl_course on tbl_score.courseno= tbl_course.courseno group by tbl_course.courseno order by tbl_course.coursename desc; 变量 系统会话变量以两个@开头 用户会话变量以一个@开头 用户会话变量例：:创建用户会话变量@name，并赋值为“张三” 123set @name=“张三”- 或select @name:=“张三” 局部变量例：定义局部变量myvar，数据类型为int，默认值为100，并赋值60 12declare myvar int default 100;set myvar = 60; 自定义函数例：创建一个名为func_course的函数，返回表course中指定课程号的课程名 1234567delimiter &amp;&amp;create function func_course(c_no char(3))returns varchar(20)begin return(select coname from course where courseno=c_no);end &amp;&amp;delimiter ; IF 条件控制 函数中使用if 例：创建函数exam_if，判断传入的参数如果是10，是则输出1，否则判断是否是20，是则输出2，否则输出3 1234567891011delimiter //create function exam_if(x int)returns intbeginif x=10 then set x=1;elseif x=20 then set x=2;else set x=3;end if;return x;end //delimiter ; 查询中使用if() 例：从成绩表中查询学号为60121901的学生成绩信息,如成绩大于等于80分，显示“通过”，否则显示“未通过” 123select *,if(finalscore&gt;=80,'通过','未通过') as '是否通过' from score where studentno='60121901'; 查询中使用ifnull() 例：从成绩表中查询学号为60241902的学生成绩信息,如成绩为null，显示“没有成绩”，否则显示成绩 1select * ,ifnull(finalscore,'没有成绩') from score where studentno='60241902'; while循环例：定义函数exam_while,求1到n的和 123456789101112delimiter //create function exam_while(n int) returns intbegin declare sum int default 0;declare m int default 1;while m&lt;=n doset sum =sum+m;set m=m+1;end while;return sum;end //delimiter ; 储存过程 无参数 例：创建存储过程proc_stu，从数据库school的student表中检索出所有2001年出生的学生的学号、姓名、出生日期等信息 123456delimiter //create procedure proc_stu()begin select * from student where year(birthday)='2001';end //delimiter ; 有参数 例：创建存储过程stu_score的，统计指定同学的考试门数 1234567delimiter //create procedure stu_scores(in s_no char(8), out count_num int)reads SQL databeginselect count(*) into count_num from score where studentno=s_no;end //delimiter ; 调用：call stu_scores(‘18125121107’, @c_num ); 查看：select @c_num; 触发器 在表数据修改后激活的指令 例：创建一个触发器，当更改表course中某门课的课程号时，同时将score表课程号全部更新 1234567delimiter $$create trigger cno_update after update on course for each rowbegin update score set courseno=new.courseno where courseno=old.courseno;end $$delimiter ; update on 更新后 delete on 删除后 insert 插入后 例：在de_teacher表插入记录前和插入记录后，分别向before_insert和after_insert中插入一条记录 123456789create trigger before_insert before insert on de_teacher for each row insert into bef_after set teacherno =‘t11’, name =‘孙悟空’; create trigger after_insert after insert on de_teacher for each row insert into bef_after set teacherno =‘t22’, name =‘猪八戒’; 用户管理 添加 例：添加两个新用户，用户名zzz,密码zzz001,用户名qqq，密码qqq002 123create user 'zzz'@'localhost'identified by 'zzz001', 'qqq'@'localhost'identified by 'qqq002'; 修改名称为rename 修改密码 例：修改用户kkk的密码为kkk008 1mysqladmin -u kkk -p password &quot;kkk008&quot; 例：更新密码 1mysqladmin -u username -p password &quot;newpassword&quot; 删除用户 例：删除普通用户kkk 1drop user kkk@localhost; 或 12delete from mysql.user where host='localhost' and user='kkk'; 权限管理授予权限例：创建一个新用户zzz,密码为zzz001，用户zzz对所有的数据有查询、插入权限，并授予grant权限 123create user ‘zzz’@‘localhost’identified by 'zzz001'； grant select,insert on *.* to 'zzz'@'localhost' with grant option; 例：查询用户zzz的权限 1show grants for 'zzz'@'localhost' 收回权限例：收回用户zzz的insert权限 1revoke insert on *.* from 'qqq'@'localhost'; 例：收回用户zzz的所有权限 1revoke all privileges,grant option from 'qqq'@'localhost'; 报错处理14181set global log_bin_trust_function_creators=1;","link":"/posts/39805/"},{"title":"三月死在了下旬","text":"太难受了。不知何时感染的甲流，重击了我本就跌宕的生活。 噩梦的两个星期从第一次发烧开始，38.1 摄氏度，还算正常，当日吃了对乙酰氨基酚，直接退烧了，下午还正常的参与活动。直到第二天早上起来，人都不对劲了，再次发烧，头晕眼花的。接下来几天就是不断地退烧再复烧。继续吃了几片对乙酰氨基酚，只有一定的效果。 伴随着浑身酸痛，喉咙开始发炎了，于是对症下药磕了几粒阿莫西林，效果不佳。 体育课直接和老师说休息了，在椅子上恍惚着看同学们打球，下次体育课就要 3v3 考试了，有点焦虑。体制干预课也拿着保温瓶、穿着羽绒服看着同学们运动。 期间的排球训练我没错过，但也无法挥手扣球了。 严重的症状大概持续了一个星期，后一个星期就好多了，但是后遗症还是有的，不发烧了，但是一直咳嗽。痰很粘稠，很难吐出来，和新冠不一样，那时候吐痰非常简单，呵一下就出来了，这次咳的我肚子疼想干呕，都难以吐出。直到现在基本可以突出，咳嗽也不多了。 两个星期基本没背单词。学业也基本荒废，简单来说就是啥也没干，天天打游戏看电视，也花了不少钱，吃占了七七八八，但是并不是很有胃口。吃东西都没啥味道，或者是苦苦的，烦。 之前一直记账的习惯也被这次生病终结了，不想记账了，每天扒拉扒拉这些零零散散，搞得我头都大了，该吃吃该喝喝吧。 什么是幸福生病期间我一直在想，果然还是身体健康最重要，其他都是浮云。没有健康的体魄，啥都没意义了，连我最喜欢的最幸福的吃，都成了痛苦，那生活还有什么意思。 之前央视记者问大家：“你幸福吗？” 回答：“我姓曾。” 我觉得这是绝顶的答案了，这个时代，温柔或严厉的批评大概说不得，连赞美都要知轻重，轻了重了，味道居然就变了。而这一句“我姓曾。”，击碎了所有褒贬的逻辑。 和记者问吃饭的人为什么不戴口罩有异曲同工之妙。 按我来说，吃好喝好，就很幸福了。食欲表达一切。饭都吃不下，何谈幸福。 显然，甲流让我非常不幸福。 小结三月的复盘总结什么都没干。 三月死在了下旬。","link":"/posts/52935/"},{"title":"全面拥抱二月","text":"二月相当努力，至少与这几个月的放荡相比是这样的。 关于笔记最重要的是有一直在写日记，而且有序的记录了自己的学习曲线。在之前是很难去想象的。对于笔记这个东西我曾走过很多弯路，当然现在也不一定是最好的最对的，但是相对来说还是有进步。 最开始也是一开始在电脑上记录，后来逐渐形成月制周制，倾向于写成一篇博客然后发布。说实话，将日记这种较为私密的记录生活的文字放载到公共空间，实在是不妥，一是隐私问题，二是有一种功利的心理——似是专门写给大家看的，而不是给自己看。 于是花了很长时间去思考日记的意义，然后选择了传统的手账日记（其实很大受到阿弥的影响）。虽说是手账，但那些复杂的、花里胡哨的装饰我是不屑和懒得去折腾的，于是还是单纯的只有文字（现在就算电子笔记也是如此，我觉得这样非常纯粹和易于管理）。那段日子发生的事相当记忆深刻，也许是因为特殊的人和事情，也许是因为用新买的钢笔和手账簿记录了。 很显然的，后来我又放弃了，原因很难想到，至少我一开始没想到：到学校寝室里，拿笔记时常容易被室友看到，就算看到里面一点点我也非常不舒服，但是我又很难在一天的结尾到外面去写日记。或许在床上写也是个不错的选择，但是非常不舒服，严重抑制了我写日记的热情。 于是又开始思考笔记、日记的记录方法，有什么又方便又舒适，又不会被窥探到的方法呢？ 最后选择了 Obsidian 本地使用 markdown 语言记录，解决了一些痛点，暂时用到现在。 对于被室友看到的解决方案：Obsidian 调整文字大小很方便，按住 Ctrl+滚轮 就可以调整，于是当我写私密文字的时候就可以将文字调整成最小，站在旁边的人是绝对看不清的，就算我坐着也有些吃力，但不至于看不了。 论方便程度，我是觉得还不错的，本地备份 + Onedrive + Obsidian 插件 实现全端备份，点一下就可以同步，电脑编辑完，手机上也可以接力，非常舒适。 Obsidian 的一些辅助插件也能提升码字的舒适度，包括但不限于模板、自动字符排版和双链等等。 除却日记，关于更多的笔记——课程的、自学的、读后感等等，也使用 Obsidian All in 了，打标签 + 文件夹管理的模式非常方便。 学了什么 java 基础复习了一半了，说的好听叫复习，其实之前学 java 时的一些细节问题根本没仔细解决，现在重学一遍，收获良多。 四级核心单词又过了一遍，这次相当认真，平均每天花了两个小时左右。 尤克里里方面，学会了《突然好想你》，但还有些地方不连贯，《未闻花名》还在练习，不过相当难。 日语学了基本五十音。 git 基础也重学了一下。 润的想法说实话可能是最近负面新闻接收太多了——也不知道是本身生活就是负面居多，还是刻意接收到的多了——最近这三年发生的大大小小的魔幻事件让我迷茫。 我不想谈论政治经济方面的问题，但是中国的生活像是蜘蛛网一样张开，并堆叠，而且亲情这个最大的网会把人罩的死死的。所以润是非常难的，我暂且不做考虑，但是会关注。 身体吃不消这个月熬夜有点狠了，一月份刚刚得过新冠，那段软弱体虚的时光让我难受至极，于是报复性的在二月熬了好多个夜，吃了不少垃圾食品。身体当然吃不消，有时候会胸闷，头晕，精力不足，还有日渐肥胖，哎，少熬夜，多锻炼，多睡觉，身体是革命的本钱！ 学校的垃圾课程想起来就烦，这学期居然安排了关于 ERP 企业资源管理系统的课，我不明白，我一个要做程序员的为什么要学这个。为了奖学金还得认真听（背）一下，应付那弱智的考试。 还有一些不作为的老师，教授一些过时的、甚至连他们自己都根本不深入明白的课程，我不好评价，只感觉浪费时间。 以及拉跨的机器改卷，不能识别多个正确答案为什么要机改，计算机领域哪有标准答案呢。 对比赛的思考上一年参与数模比赛拿到了还算不错的成绩，老师鼓励我继续冲，拿国奖，但是我已经开摆了，因为真的很累，不是比赛有多难，而是各种麻烦事的叠加让我厌倦。 比赛不是个人赛，而是团队赛，我虽然没什么本事，但还是要鼓起勇气当作队伍里的前锋、队长那样的角色，说实话，很累，我不喜欢指使他人，给别人分配任务，因为我怕选择了错误的方向。应该都有一种指令惰性吧，喜欢接收指令去干活，而不是发布指令。我不知道为什么会养成这种习惯，应该是不太好的习惯。也许和我从小乐于接受父母老师安排有关吧。 不过好在，花的时间虽然不算多也不算少，但有奖金，也不用去做麻木的体力劳动，稍微动点脑子就可以拿到钱，岂不美哉，所以这也是我参加的目的之一。而其他方面，学到了一些关于 matlab 和 latex 的知识，也算有用。 总的来说参加比赛还是不错的，能学到东西，也能挣钱，累不累看个人。但是那些要请正课的假去集训的比赛，我不好说，如果含金量不大或者拿不到大奖，还容易被挂科或者只能及格而拿不到奖学金，我觉得是有点亏的。 艺术方面这个月书和电影看得少了，虽然之前也不多。主要原因就是学习占用时间不少，而且在学校里琐事也多（比如上垃圾水课，嘈杂环境看书是一种折磨），于是几本在读书目基本没推进，也没看电影。 在有空的时候一般去图书馆了，在寝室里较为吵闹，不能学习，当然也无法欣赏一些作品。嘈杂是对艺术的扼杀。我想之后可以抠点时间出来在图书馆看电影，不过大家都在卷，而我在看电影，总觉得有些违和，不过我喜欢特立独行。我觉得每个年轻人都应该特立独行。 健身理念这个月没有运动，很全面的没有运动，大概是感染新冠给了自己一个借口：我好像很虚弱。但实际上我痊愈后天天熬夜吃外卖，对身体的伤害更大了。 近乎两个月的不运动，我有了全新的思考，因为运动是一件很消耗精力的事情，所以这件事情的确是有门槛的，而且不低。所以兴趣就是最最重要的一个前提，这可以使我不顾一些问题去向前冲。 所以之后的锻炼计划可能偏向于兴趣而非像以前一样为了肌肉、为了外表，这有点累了，生活本来就很累了，何苦自己呢。","link":"/posts/175/"},{"title":"关于2022","text":"混沌和迷茫的2022。这是一篇年终总结，关乎生活，不仅仅是学业上的一些东西。 死胡同起初重建博客的初衷是记录自己的关于编程方面的学习问题，但我走进了死胡同，既没有生活、也没有学习。单纯的笔记，可以通过本地化保存实现，并且更方便，所谓的博客，不该桎梏于所谓笔记，我发现，学习与生活绝对是无法相割裂开来的两个东西。 你说，当你遇到一个学习上的问题，你会如何去解决呢？解决方法，解决路径，这些种种程式化的，我本身而言是很讨厌的。尽管想成为一个有着清晰思路去妥善完成各种工作的人，但也绝非是这种。人从来是感性化的动物，我们不该剔除人性。于是我想再接下来的日子里，这个博客的主旋律也应该是生活。继续将生活好好记录，不管是通过文字还是各项媒介。 破碎的2022任谁而言，2022是满足和充实的呢。 已经记忆不起上半年发生的事情，好像魔幻的魔术橡皮擦在不经意间随手涂抹，我人生仅剩的百分之一时光已经消逝。 今年度过了人生中最为炎热的盛夏，炎热得仿佛不真实，脑子里只剩下空调外机和电风扇的嗡嗡噪音。酷热中重新拾起了守望先锋，遇到了一群网友，能够让我怀念起2016的那个夏天，但现在它要结束了，同样虚幻的不真实——2016年的我从未想象到守望先锋会迎来关闭国服的结局。 暑假曾回到母校看老师，没什么好讲的，老师很好，学校很好，我很不好。 在暑假结束，回学校的高铁上，我拿着平板赶着暑期社会实践的任务报告。接下来回到学校便是三天的数学建模比赛，通宵了一天，一天也是睡在教室，所幸取得一些名次，要不然会愤恨死自己，这么折腾自己的身体，如若没有什么结果，那对生理和心理都是莫大的伤害。 仍然闷热的十月份，来杭州这么久了，第一次去看了钱塘江。骑着自行车滑过拥挤的街道，细碎的晚风一边切割着银色的波浪，一边轻抚我燥热的胸膛。每隔几十米能见到在路上唱歌的人、跳舞的人和野餐的人，人各有各的幸福。左方能够望见钱塘江大桥，斑驳的车尾灯呼啸，在远处的我只见一丝丝红黄闪现而过。桥只管巨大的伫立在那里，无论如何。而我万不能伫立在原地，我得奔跑。 随同学去杭州各地景点摄影，正是在摄影的路上，我发现自己并不是喜欢摄影，只是喜欢好看的风景，摄影对于我而言，仅是保存那些画面的一个步骤。任意学问都有它自己的独特之处，我不揣摩我不明白也并不想深入的事物。 同样是十月份，在寝室的饮水机旁发现一颗蘑菇，顶好的生长着，尽管它第二天枯萎死去了。一定是饮水机漏水有点严重，12月份时饮水机也换新了，寝室没有人愿意搬它下楼，是我顺手搬下去了，再把新的抬上来。 蔡赠送了我一本2023的豆瓣日历，我那时想日子还远着呢，2022相当漫长啊，没想到要开始使用了。日历是个好东西，它能提醒我日子如水，淌着淌着就过去了。 如愿拿到了驾照，过程相当曲折，科目三是除高考外人生最折磨却不是最痛苦的实践经历，一无是处是书生，书本毫无作用。越长大越发现，所谓想回到小时候不是因为小时候有多舒服，有多快活，而是因为光是可以沉浸在书本当中，而不用去切身处理生活的琐碎，便已经是莫大的幸福了。 十一月份仍旧穿着短袖，酷热难耐，这回终于去了一趟动物园。说来惭愧，我从未去过动物园，唯一一次有机会，是在小学的某一次春游当中，而遗憾的是，那会儿老师好像说，因为成绩还是某些原因，某些同学不能去，很不巧，我就是那些同学之一，于是我在一个大家都去动物园的日子里放假了，但我没有伙伴可以一起玩耍，因为大家都在动物园。 熊、秃鹫、白虎、海狮等等动物，我只在视频中见过，如今见到了，相当欣喜。不过美中不足的是，动物们普遍无精打采，甚至带病上岗，动物也在疫情中累了么。最烦的是一个地方的许多大号鹦鹉，狂叫，震得耳膜生疼，没有看它们的欲望。最可惜的是，逛了一天也没找着熊猫馆，最后发现，原来在出口上写着熊猫馆维护了。袋鼠很可爱，于是狠狠的拍照，没有长焦镜头，也用数码变焦狠狠的放大来给它的肌肉一点特写。 突然的，十一月底下雪了，大片大片的雪花在身上落下，没见过几次大雪的南方孩子眼珠子已经离不开那些亮晶晶的雪花了。我后悔没有跟朋友们一起去堆雪人，现在来看，肯定是相当快活的回忆。 同样在十一月底，输掉了排球比赛，很懊恼，没有发挥应有的水平，虽然水平也不高，不过还是懊恼。接下来的日子，一定要狠狠的锻炼，狠狠的赢上那么几场比赛，狠狠的拍照庆祝，狠狠的在团建上喝上那么几杯。 12.7，《放牛班的春天》重映了，于是赶着去重温了一遍老师的温柔，坐在只有四个人的影院里，我觉得音乐是有灵魂的。 接下来就回家了，早早的回到了温州，然后在一次朋友聚会中阳了，卧病一周，刚好赶上了这年底。 恰好能从一年初始而重新开始计划和奋斗，这是非常好的开始。我喜欢开始这个词，能开始也是莫大的幸福。 该死的自律这年中，书没读几本，单词没背几个，身体也没好好的去锻炼，总而言之，是缺乏自律的一年。吃的是非常不健康但好吃的东西，作息是非常不健康但很爽的生物钟，学习方面也是三天打鱼两天晒网。当下过得非常愉快，但给我兜底的是我的人生。有人说每天百分之一的进步，日积月累会有很好的回报，而我每天百分之一的退步，那积累的错误是何等量级呢。 今年的自律，理应从早睡早起开始。 关于2023因为还年轻，一切都是变数，不是30岁的而立，不是40岁的中年，生活中心已经压在了一处，身子都无法挪移一点，重大的变动的后果是难以接受的，而年轻的我可以开始，在任何地方开始。 希望2023有更强壮的身体，更平和的心态，更聪明的大脑。 结每当动笔，就有一种没什么好写的感觉袭来，像傍晚飕飕的冷风，提醒你将步入阴寒的黑暗了。这种感受蔓延到任何事物，无论做什么都有一种不够及时的满足感。但不能止步于此，继续坚持着续写人生的长文吧。 各位新年吉祥。","link":"/posts/14413/"},{"title":"小米平板5 Windows10 痛点解决 ＆ 使用技巧","text":"资源下载链接都在文章末尾。 系统 win10 21390.2025 精简无水印（小白之家制作，已获得转载权），请于文章末尾云盘下载。 个人体验来说，win10 是比 win11 流畅不少的。 驱动 （息屏、麦克风已修复）：Mindows 工具箱检查更新一直提示失败，不知道是不是我的问题，文章末尾云盘提供已经覆盖麦克风驱动的备份。 使用方法：解压并覆盖Mindows工具箱V7-小米平板5\\bin\\driver\\nabu，在工具箱内安装驱动即可。 USB/充电 问题： 注册表快速更改.reg 文件 注册表位置：HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Enum\\ACPI\\QCOM0597\\0\\Device Parameters 需调整项目：RoleSwitchMode = 1/3 RoleSwitchMode 调为 3 并重启：u 盘如果插着重启可以识别但无法热拔插。可热拔插连接别的设备，作为输出识别，如平板连接电脑后，平板会识别为设备并可以向平板传输文件。 RoleSwitchMode 调为 1 并重启：可单独热拔插 u 盘 / 充电，如果先插了 u 盘，就无法再充电了，先插了电源，依旧可以热拔插 u 盘，简单来说就是没有拓展坞的情况下，充电和 u 盘二选一，且 usb 优先级高于充电。如果使用拓展坞连接电源启动，便可以充电的同时热拔插 u 盘，但拔掉电源后无法再识别电源。 手写笔可用，但无法连接蓝牙使用按键。 软件 微软商店：经我个人多次安装测试，启动系统后有概率无法直接开启微软商店，此时离线安装最新微软商店即可，云盘中我已提供。 Office：我个人是使用了 Office Tool plus 安装了企业应用版 Office365，再使用 kms 激活即可，同步正常。注意选择 arm 版本安装。 parsec 串流：平板可以完美控制别的设备，但是可能因为没有匹配显示驱动，无法在别的设备控制平板，连接后鼠标键盘可操作，但屏幕不显示。 Java for arm64：提供安装包，安装即可，不过需要手动配置环境变量。 远程桌面：win+r 输入 mstsc 运行即可。 微软白板：很好用，但是运行偶尔会崩溃。 Excel：打开 13MB 的纯数据表格花了 10s，绘制 14 行 100 列柱状图秒出图。 VsCode：流畅使用。 VLC UWP：微软商店安装即可，原生 ARM。 texlive：编译 latex 文件，安装时会提示系统不支持，右键编辑安装的 bat 文件，将如图所示部分删除并保存，再次运行安装即可。 游戏 Minecraft for Windows： 原生 arm64，比较流畅，默认设置下感觉 50fps 左右，只能说能玩。 Minecraft Java：原版，30-40 fps，4-6 显示距离，体验一般（这是在 win11 下测试的，win10 可能好一些）。 Minecraft Java Server：完美运行，需要自行配置好 java 路径。 帝国时代 2：征服者：翔鹰版本，流畅运行，很爽。 GTAVC 罪恶都市：不知道是游戏问题还是系统问题，输入总是觉得卡卡的，就是操作慢一拍，复杂场景帧数很低，玩不下去。 Galgame：这里才是主战场，随便推，最合适的游戏场景。 星之终途：逆转裁判： 其他 一键切换安卓的 bat 文件请以管理员权限运行。 系统激活软件在云盘中有提供。 有线直连拓展屏幕需要支持 displaylink 的拓展坞。 关于商店无法安装任何软件并提示“我们这边出了错”，我网上查到是 ms id 问题，我注销账号也无法解决，也许使用一个新的微软账号登陆可以解决问题。但如果不想这样就只能离线安装 uwp 软件，或者重装系统。 下载https://www.123pan.com/s/yKq5Vv-rYmVv.html","link":"/posts/22150/"},{"title":"小米平板5 Windows11 体验报告 &amp; 注意事项","text":"省流：完全可以刷入日用。 自购买 pad5 到现在，一晃一年过去了，这一年确实实现了无纸化学习（PDF+笔记），也用 pad5 玩了很多花样（如使用容器安装 linux 并远程图形界面，实现 wps 和 vscode 的使用等等）。 但在安卓上的虚拟化应用体验并不好，甚至可以说卡的完全不适合日用。时隔一年，在众多开发者的支持下，Windows for pad5 的驱动终于达到可以日用的水平，于是我便刷机体验了一番。 差强人意注意，差强人意的意思是大体上还能使人满意。 没错，在各种驱动的支持下小米平板 5 上的 win11 体验已经达到了满足日用的水平，无论是手写笔还是无需供电的 usb 驱动，甚至是难以搞定的关机键熄屏睡死，也已经被修复。 是各项功能是否可用详情： 功能/驱动 是否可用 触屏 √ 音量键 √ 电池/电量显示 电量显示不准确 充电 超级慢充 CPU √ GPU √ 虚拟化 X WiFi √ 蓝牙 √ 录音 X 定位 √ 重力感应/旋屏 √ 屏幕 √ USB 热拔插 √ 扬声器 √ 亮度调节 √ 息屏/唤醒 √ 高刷 √ 相机 X 如上表所见，大部分功能都已正常实现，除了电量显示和充电较慢的痛点，但是还可以接受，电量方面打字做表格基本能坚持 6h 左右（可能）。 可取之处 可以方便的进行 win11 与安卓系统的无缝切换，并且不影响安卓的 root 等操作。 微软账号登陆正常，软件商店正常。 win11 下可以流畅运行 arm64 架构的软件，如 office 与 obsidian 等。 只要内存不崩溃，基本上操作都是比较流畅的，偶尔的小卡顿在我的可接受范围内。 续航起飞，至少比我 2-3h 的游戏本好多了。我在早上 7 点从 90%左右电量的安卓切换到 win11，并开始安装软件，浏览网页，期间看了十几分钟视频，到了 10 点切换到安卓，还剩下 60%左右电量，并不严谨，但理论上这个续航还是不错的。 可以安装 wsl1，运行 linux 子系统。 可以方便的直接用 pad5 给手机刷机，可正常连接，也可以给手机充电。 适配了小米手写笔（我是一代），不过并没有安卓那么丝滑，屏幕触摸也毫无问题。 一些缺憾 性能羸弱，非 arm64 软件经过转译体验较差，启动慢，操作卡，部分小软件体验尚可，稍微吃点压力的就不太好了。 虽有 wsl，但只是一代，不支持虚拟化，没有 linux 内核，也无法使用 wsa 运行 apk，也无法使用经典 docker。 充电问题，我在酷安看到有哥们发布了 33w 的充电驱动和教程，我还没试。并且电量显示不准确。 USB 使用无问题，但是使用过 USB 接口后，无法再进行充电，需重启才能解决。 虽说 win11 自带的屏幕键盘已经比 win10 好很多了，但是还是处于不舒服的状态，当唤起屏幕键盘时会将焦点窗口上移，腾出空间，这个过程的动画会拉长时间感受，会有卡卡的感觉。解决方式之一是使用小键盘，就如同安卓横屏下的键盘一样，可以随意拖动小键盘窗口，但 win11 的小键盘无法随意改变大小，键位小小的非常难点。 相机不可用，扫码不用想了。 小内存与较慢的传输速度，可能会拉低使用体验，我是丐版 6+128g pad5，6G 只能说码字够用，实际上光运行 edge 后，后台仅剩下 30%可用内存不到。较小的储存空间还好，我没有储存大量文件的需求。 软件推荐因为是 ARM64 架构，因此软件适配较少，但也足够用了，而且部分 X64 软件转译后也可用，推荐如下： Office，办公三件套稳稳地。 Obsidian，笔记软件，win 下体验还是比安卓好太多。 Clouddrive，将几个 T 的储存的阿里云盘挂载成磁盘不香吗？ OneNote，全端笔记。 Snipaste，截图贴图神器。 VS Code，开发必备，不用多说了吧。 Clash，好用的代理软件，arm64 构建很流畅。 能源之星 X，内存优化软件。 刷机注意事项 安卓与 win 依照分区进行分割，使用 Mindows 工具箱刷入分区表后，两者互不干扰，可以正常使用 fastboot 线刷。 需要进入 win 系统，就需要刷入 相匹配的 uefi，需要进入安卓，就需要刷入相应的 boot 镜像，可以方便的通过 Mindows 工具箱中的刷入分区镜像功能来实现。 分区表刷完后，即第一次安装 windows 完成后，以后重装 windows 无需分区，如果需要修改 win 和安卓所占空间，则需要两个系统全部都清除重装。 对于安卓与 win 一键切换，安卓端需要安装 Mindows app 并将 uefi 文件放置到安卓根目录，之后便可以在 app 内一键切换到 win 系统。 对于安卓与 win 一键切换，win 端需要安装准备安卓相匹配的 boot 镜像，如果需要 root，请将 boot 文件切换为 magisk 修补后的 boot 镜像。 对于系统，理论上来说只要是 arm64 位的 windows 镜像即可，但更推荐 Mindows 工具箱中推荐的系统。我使用的系统为 25393.1.230608-1158.ZN_RELEASE_CLIENTPRO_OEMRET_A64FRE_ZH-CN.ISO 小结现在 pad5 的 win11 完全可以应付一些基础的聊天、码字、看视频和轻度开发，并且有着轻便和高续航的优点，绝对是出门不错的选择。 并且经过各位开发者的努力，现在刷入 win11 非常方便，有 Mindows 工具箱 这种傻瓜式安装脚本，只要在安装过程中严格对照指示，理解分区和操作原理，基本上可以无痛刷入 win11。","link":"/posts/30501/"},{"title":"豆瓣电影TOP250爬虫","text":"这是一项Python爬虫课的期末作业。 前情提要Python爬虫课的期末作业是自由选择一个网站爬取，那我就本着多一事不如少一事的原则选了豆瓣电影Top250这个最模板化的网站，而且网上也有很多很多例子可以借鉴。别的不说，我也挺喜欢看电影的，刚好理一遍，慢慢看这250个电影。不过期末周哪个孩子有时间看电影啊！ 分析打开豆瓣电影Top250，可以看到电影按十个一页降序排列在页面中，而且电影相应的海报图片和简介以及评分和一句话的评价都整合在一个框架当中。整个豆瓣电影TOP250排行榜共有250个电影，以25个一页分为10页。 点击第二页，可以看到网站链接的变化：https://movie.douban.com/top250?start=25，从其中可以知道start参数即此页及其之前页的电影数量，以此类推start=0为第一页，start=25为第二页，start=50为第三页…… 通过肉眼观察和F12，可以知道每个电影所在的div框架是包含了他所有信息，所以要么通过正则来匹配需要爬的信息，要么通过bs4模块先提取需要的源码块再进行数据清洗。 代码我为了逻辑更清晰，将要爬取的信息分为成了不同的模块去爬取，电影名称，电影评价，电影图片等等，但是缺点很明显，代码量很大，数据清洗要根据不同情况分批进行，再存到不同列表中。 改进方法就是写一个爬取所有需要信息的正则与bs4模块提取的框架，将所有信息进行数据清洗，再放到一个列表中，这样效率会高很多，代码量也小。 此次代码用到了异常捕获，主要是为了防止图片下载失败，因为自己寝室里网络不错，运行完美，到了机房，访问豆瓣图片库有时候会G，所以要写一个重新尝试下载功能。 还有文件管理，启动程序前先检查需要的目录是否存在，是否有同名文件冲突，如果有则创建或删除。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178# -*- codeing = utf-8 -*-import reimport sqlite3import timeimport urllib.requestfrom bs4 import BeautifulSoupfrom prettytable import PrettyTable# 模拟浏览器headers = (&quot;User - Agent&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36&quot;)opener = urllib.request.build_opener()opener.addheaders = [headers]# 将opener安装为全局urllib.request.install_opener(opener)# 保存每页的链接def save_img_url(data): path=&quot;img_url.txt&quot; file=open(path,&quot;a&quot;) file.write(data+&quot;\\n&quot;) file.close()# 保存图片到本地def save_img(): for p in range(0,10): flag = True url = &quot;https://movie.douban.com/top250?start=&quot; + str(p * 25) data1 = urllib.request.urlopen(url).read().decode(&quot;utf-8&quot;) # 将每页的链接保存到本地 save_img_url(url) # 获取到所有海报图片链接头，无后辍.jpg pat = re.compile(r'&lt;img.*src=&quot;(.*?).jpg&quot;') # .*?表示字符出现一次或0次，re.S表示忽略换行 img_url = pat.findall(data1) for a_i in range(0, len(img_url)): loop = True # 使用一个while循环，在当爬取任意一张图片出现问题时，重新爬取一次 while loop: try: this_img = (img_url[a_i]) # 图片链接加入后缀.jpg this_img_url = this_img + &quot;.jpg&quot; print(this_img_url) img_path = &quot;img/&quot; + str((a_i + 1) + p * 25) + &quot;.jpg&quot; print(&quot;正在爬取第&quot;, str((a_i + 1) + p * 25), &quot;张图片&quot;) urllib.request.urlretrieve(this_img_url, img_path) time.sleep(0.1) # 每张图片下载间隔0.1秒 loop = False # 如果没问题就不循环了，有问题这条不执行而执行except中的内容 except: print(&quot;图片爬取错误，正在重试！&quot;)# 保存所有电影数据def save_all(): titles = [] kinds = [] ranks = [] quotes = [] viewns = [] for p in range(0,10): # 设置url并解析html url = &quot;https://movie.douban.com/top250?start=&quot; + str(p * 25) data1 = urllib.request.urlopen(url).read().decode(&quot;utf-8&quot;) #电影名称爬取 pat1 = re.compile(r'&lt;span class=&quot;title&quot;&gt;([^&amp;]+)&lt;/span&gt;',re.S) # .*?表示字符出现一次或0次，re.S表示忽略换行 [^&amp;]+即排除中间有&amp;号的一次或多次 ()内即为爬到的东西 title = pat1.findall(data1) # # 对得到的列表进行数据清洗 # for i in range(0,len(img_url)): # img_url[i] = re.sub('&amp;nbsp;/&amp;nbsp;', '', img_url[i]) titles = titles + title # print(titles) # 电影种类爬取 pat2= re.compile(r'&lt;br&gt;(.*?)&lt;/p&gt;',re.S) # .*?表示字符出现一次或0次，re.S表示忽略换行 kind = pat2.findall(data1) # 对得到的列表进行数据清洗 for i in range(0,len(kind)): kind[i] = re.sub('&amp;nbsp;', '', kind[i]) kind[i] = re.sub(' ', '', kind[i]) kind[i] = re.sub(' ', '', kind[i]) kind[i] = re.sub('\\n', '', kind[i]) kinds = kinds + kind # print(kinds) # 电影评分爬取 pat3 = re.compile(r'&lt;span class=&quot;rating_num&quot; property=&quot;v:average&quot;&gt;(.*?)&lt;/span&gt;',re.S) # .*?表示字符出现一次或0次，re.S表示忽略换行 rank = pat3.findall(data1) # # 对得到的列表进行数据清洗 # for i in range(0,len(img_url)): # img_url[i] = re.sub('&amp;nbsp;/&amp;nbsp;', '', img_url[i]) ranks = ranks + rank # print(ranks) # 电影评论人数爬取 url = &quot;https://movie.douban.com/top250?start=&quot; + str(p * 25) data1 = urllib.request.urlopen(url).read().decode(&quot;utf-8&quot;) # print(url) pat4 = re.compile(r'&lt;span&gt;(.*?)&lt;/span&gt;',re.S) # .*?表示字符出现一次或0次，re.S表示忽略换行 viewn = pat4.findall(data1) # 对得到的列表进行数据清洗 del viewn[0: 6] viewns = viewns + viewn # print(viewns) # 电影精华短评爬取 soup = BeautifulSoup(data1,&quot;html.parser&quot;) # 指定Beautiful的解析器为“html.parser” # 注：解析器负责把 HTML 解析成相关的对象，而 BeautifulSoup 负责操作数据（增删改查）。“html.parser” 是 Python 内置的解析器 for item in soup.find_all('div', class_=&quot;item&quot;): # 查找符合要求的字符串，形成列表(注：class是一个类别/属性，需要加下划线，否则会报错) # 这里的循环将每个item，即每个电影的代码框架遍历，共25个 pat5 = re.compile(r'&lt;span class=&quot;inq&quot;&gt;(.*)&lt;/span&gt;') # 从每个代码框架中找出评价，若没有评价，则将评论留空 item = str(item) quote = &quot;&quot;.join(re.findall(pat5, item)) # 将列表元素转换为字符串 if len(quote) != 0: quotes.append(quote) # 添加 else: quotes.append(&quot; &quot;) # 留空 # print(quotes) print(&quot;第&quot;, p+1, &quot;页爬取完毕&quot;) print(&quot;---------------------------&quot;) print(&quot;检查数据正确性：&quot;) print(&quot;影片名称个数&quot;, len(titles)) print(&quot;影片种类个数&quot;, len(kinds)) print(&quot;影片评分个数&quot;, len(ranks)) print(&quot;影片评分人数个数&quot;, len(viewns)) print(&quot;影片精华简评个数&quot;, len(quotes)) #将数据保存到SQL数据库 conn = sqlite3.connect('Spider.db') print(&quot;建立并打开数据库 Spider.db 成功！&quot;) c = conn.cursor() c.execute(''' create table Movie(ID int primary key not null, title varchar(50), kind varchar(50), ranks varchar(50), viewer varchar(50), quote varchar(50)); ''') print(&quot;表Movie创建成功！&quot;) print(&quot;开始向Movie表插入数据&quot;) for i in range(0,len(titles)): c.execute(''' insert into Movie values(?,?,?,?,?,?); ''', (i+1, titles[i],kinds[i],ranks[i],viewns[i],quotes[i])) print(&quot;数据插入Movie成功！&quot;) conn.commit() conn.close()def select_sql(): # 创建放置查询结果的输出表格，设置其表头 tb = PrettyTable() tb.field_names = [&quot;ID&quot;, &quot;电影名称&quot;, &quot;种类&quot;, &quot;评分&quot;, &quot;评论人数&quot;, &quot;优秀短评&quot;] conn = sqlite3.connect('Spider.db') c = conn.cursor() print(&quot;开始查询SQL数据库的Movie表：&quot;) cursor = c.execute(&quot;SELECT * FROM Movie&quot;) for row in cursor: tb.add_row([row[0], row[1], row[2], row[3], row[4], row[5]]) print(tb) print(&quot;SQL数据库查询成功！&quot;) conn.commit() conn.close()def main(): print(&quot;开始爬取数据！&quot;) save_all() print(&quot;数据爬取完毕！4秒后开始爬取图片&quot;) print(&quot;---------------------------&quot;) time.sleep(4) save_img() print(&quot;图片爬取完毕！请在img目录下查看对应ID图片&quot;) print(&quot;4秒后开始查询数据库Movie表&quot;) print(&quot;---------------------------&quot;) time.sleep(4) select_sql()if __name__ == &quot;__main__&quot;: main() 小结这些代码陆陆续续写了十几个小时，因为之前上课一直摸鱼，老师讲的也很含糊，并没有想让我会的意思，于是基本上很多爬虫知识都是临时搜索和复制黏贴来的，不过有认真思考程序的运行思路与错误优化。","link":"/posts/45300/"},{"title":"用Scrapy框架爬取豆瓣","text":"这是一项Python爬虫课的课程综合实践作业。 前情提要这个Python老师就喜欢整些花的，上课时间也飘忽不定，然后让我们用从来没用过的Scrapy框架在两天内自学完成一个简单爬虫，真不错，所以浅浅的学了一下，发现Scrapy爬虫的效率真的很高，而且稳定，用Xpath来定位标签也很方便。 分析目标网站是豆瓣电影TOP250，还是和之前差不多，250个电影为每页25个分为10页， 每个电影包含其电影海报、电影评分、电影评论等信息。不同的是之前通过正则表达式过滤来从源码中获取想要的信息，而且也用到了bs，因为re虽然匹配强，但是无法对信息顺序有一个记录，而这次使用Xpath来定位信息并抓取，相比手动撰写的re正则表达式，能够在F12中复制的Xpath可太舒服了。 代码创建Scrapy项目crapy startproject doubansp 创建一个爬虫先到刚才创建的文件夹下面： cd doubansp 再创建两个爬虫并指定名称和其域名(其实可以手动创建)： scrapy genspider pictureSpider movie.douban.com scrapy genspider imgdown movie.douban.com items.py在这个文件中定义一些容器来存放获取到的数据。 123456789101112131415161718192021# Define here the models for your scraped items## See documentation in:# https://docs.scrapy.org/en/latest/topics/items.htmlimport scrapyclass DoubanspItem(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() # 信息容器 movie_name = scrapy.Field() movie_star = scrapy.Field() movie_quote = scrapy.Field()class DoubanspItem2(scrapy.Item): # 图片容器 img_url = scrapy.Field() img_names = scrapy.Field() spiders/imgdown.py在这个文件中编写下载图片功能的爬虫代码。 这里使用custom_settings参数来指定这个爬虫使用的管道，防止图片下载的管道在运行获取信息的爬虫时造成数据错误。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import scrapyfrom scrapy.spiders import Spiderfrom scrapy.selector import Selectorfrom doubansp.items import DoubanspItem2class imgdown(Spider): # 爬虫名称 name = &quot;imgdown&quot; # 开始链接 start_urls = [&quot;https://movie.douban.com/top250&quot;] for i in range(1, 10): start_urls.append(&quot;https://movie.douban.com/top250?start=%d&amp;filter=&quot; % (25 * i)) # 指定使用管道 custom_settings = { 'ITEM_PIPELINES': { 'doubansp.pipelines.MyImagesPipeline': 100, } } # parse function def parse(self, response): item = DoubanspItem2() sel = Selector(response) # 使用xpath定位图片链接所在位置 images = sel.xpath('//*[@id=&quot;content&quot;]/div/div[1]/ol/li') # 定义图片链接与名称容器 item['img_url'] = [] item['img_names'] = [] # append the url and name of the image in item for image in images: # extract url and name of the image # 获取图片链接 site = image.xpath('div/div[1]/a/img/@src').extract_first() # 获取图片名称 img_name = image.xpath('div/div[1]/a/img/@alt').extract_first() # 获取电影排名顺序 rank = image.xpath('div[@class=&quot;item&quot;]/div[@class=&quot;pic&quot;]/em/text()').extract_first() item['img_url'].append(site) item['img_names'].append(rank + ' ' + img_name) yield item spiders/PicturespiderSpider.py在这个文件中编写获取电影数据的爬虫代码，名字有picture是因为一开始准备在这个文件里编写图片下载功能的，但是后面出了点问题又在另一个爬虫文件里写，然后懒得改这个名字了，有需求可以自己改一下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import reimport scrapyfrom scrapy.spiders import Spiderfrom scrapy.selector import Selectorfrom doubansp.items import DoubanspItemclass PicturespiderSpider(scrapy.Spider): # 设置模块名称 name = 'db' # 所爬取的域名 allowed_domains = ['movie.douban.com'] # 开始的网址 start_urls = ['https://movie.douban.com/top250'] # 指定使用管道 custom_settings = { 'ITEM_PIPELINES': { 'doubansp.pipelines.DoubanspPipeline': 100, } } def parse(self, response): # print(response.body) selector = Selector(response) # print(selector) # 定义Xpth所在标签，info包含一般电影信息 movies = selector.xpath('//div[@class=&quot;info&quot;]') for movie in movies: # 定位电影名称所在位置 movie_name = movie.xpath('div[@class=&quot;hd&quot;]/a/span/text()').extract() for i in range(0,len(movie_name)): movie_name[i] = re.sub('\\xa0/\\xa0', '', movie_name[i]) # 定位电影电影评分所在位置 movie_star = movie.xpath('div[@class=&quot;bd&quot;]/div[@class=&quot;star&quot;]/span[@class=&quot;rating_num&quot;]/text()').extract() # 定位电影评论所在位置 movie_quote = movie.xpath('div[@class=&quot;bd&quot;]/p[@class=&quot;quote&quot;]/span[@class=&quot;inq&quot;]/text()').extract() #print(movie_name) #print(movie_star) #print(movie_quote) item = DoubanspItem() # 将爬取到的信息放进item中的容器当中 item['movie_name'] = movie_name item['movie_star'] = movie_star item['movie_quote'] = movie_quote yield item # print(movie_name) # print(movie_star) # print(movie_quote) # 对下一页链接进行获取定位 next_page = response.selector.xpath('//span[@class=&quot;next&quot;]/link/@href').extract() if next_page: next_page = next_page[0] # 将下一页的标签参数进行更改递增25 yield scrapy.Request('https://movie.douban.com/top250' + next_page, callback=self.parse) pipelines.py在这个文件中，对Scrapy管道进行编辑，定义一个MyImagesPipeline类用于保存图片。 12345678910111213141516171819202122232425262728293031from itemadapter import ItemAdapterfrom scrapy import itemfrom scrapy.pipelines.images import ImagesPipelinefrom scrapy.http import Requestclass xsPipeline: def process_item(self, item, spider): return item# 图片下载管道class MyImagesPipeline(ImagesPipeline): def get_media_requests(self, item, info): if item['img_url'] is not None: for url in item['img_url']: yield Request(url, meta={'item': item, 'index': item['img_url'].index(url)}) # rename the image # 保存图片 def file_path(self, request, response=None, info=None): # 获取图片 item = request.meta['item'] index = request.meta['index'] # 获取图片名称 image_name = item['img_name'][index] # 设置图片名称并保存 return 'img/%s.jpg' % (image_name) setting.py1234567891011121314151617BOT_NAME = 'doubansp'SPIDER_MODULES = ['doubansp.spiders']NEWSPIDER_MODULE = 'doubansp.spiders'# 指定编码格式FEED_EXPORT_ENCODING = 'utf-8'# 设置UAUSER_AGENT = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.5005.124 Safari/537.36 Edg/102.0.1245.41'# 设置管道顺序（因为在爬虫文件中指定了，其实没必要）ITEM_PIPELINES = {'doubansp.pipelines.DoubanspPipeline': 100, 'doubansp.pipelines.MyImagesPipeline':200 }IMAGES_URLS_FIELD = 'url'IMAGES_STORE = r'.' main.py令人折磨的其实是这里，因为我是分成两个爬虫写的，之前没有为图片爬虫指定管道，导致数据交叉产生错误，然后又使用scrapy自带的cmdline函数来执行启动爬虫的命令，它会导致执行完一条命令后，直接让程序关闭，然后就G了，所以想要多条爬虫按顺序运行，必须使用os.system函数来执行爬虫启动命令。 12345import osos.system(&quot;scrapy crawl imgdown&quot;)# 将爬取到的信息保存成josn文件os.system(&quot;scrapy crawl db -o douban.json -t json&quot;) 小结入门Scrapy的坑还是很多的，我从早到晚就为了解决指定管道的问题，一开始剑走偏锋像网上查到的使用IF语句在管道内判断是哪个爬虫调用，然后一直出BUG或者直接没用，最后才发现直接在爬虫里指定管道就可以了，小问题浪费大时间，典中典了。","link":"/posts/34819/"},{"title":"车票管理系统","text":"这是Java课程的期末考试题之一。 前情提要Java老师发了四道题，说是期末考试时在其中每人随机抽一道作为考题。这属于很放水了，而且题目都不难，主要是考界面设计和人性化设计，大概是还没有学数据结构和算法的缘故，在代码思维上基本都不难。 所以保险起见都做掉了，这是其中一道。 分析问题： 利用所学的Swing控件，及不同的事件处理接口，设计一个火车订票用户界面。要求在一个JComboBox（下拉框）选择车票的种类（如：“杭州——&gt;宁波”），在文本框1中自动出现该票的单价，在文本框2中显示剩余票的张数。当用户在文本框3中输入购买的张数，并按下“购买”按钮时，在文本区中显示总价格，并要及时更新剩余张数。要求：合理应用布局设计，注意界面美观、友好。（可考虑异常处理） 使用Swing控件设计成了一个比较小的窗口，麻雀虽小，五脏俱全（其实还想做个车次编辑但是懒） 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220package com.test.four;import javax.swing.JFrame;import javax.swing.JComboBox;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.ItemEvent;import java.awt.event.ItemListener;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;import javax.swing.DefaultComboBoxModel;import javax.swing.JLabel;import javax.swing.JOptionPane;import javax.swing.JTextField;import javax.swing.JButton;public class Demo { private static JTextField tf_price; private static JTextField tf_sytk; private static JTextField tf_buytk; private static JTextField tf_start; private static JTextField tf_finish; private static JTextField tf_hdtk; private static JComboBox cb; private static JButton bt_buy; private static JButton bt_add; private static JButton bt_del; public static void main(String[] args) { JFrame myFrame = new JFrame(&quot;火车订票&quot;); myFrame.setVisible(true); myFrame.setSize(300,200); myFrame.getContentPane().setLayout(null); cb = new JComboBox(); cb.setModel(new DefaultComboBoxModel(new String[] {&quot;宁波 → 杭州&quot;, &quot;温州 → 杭州&quot;})); cb.setBounds(10, 10, 130, 21); myFrame.getContentPane().add(cb); JLabel lblNewLabel = new JLabel(&quot;\\u5355\\u4EF7\\uFF1A&quot;); lblNewLabel.setBounds(177, 69, 56, 15); myFrame.getContentPane().add(lblNewLabel); tf_price = new JTextField(); tf_price.setBounds(220, 66, 54, 21); myFrame.getContentPane().add(tf_price); tf_price.setColumns(10); JLabel label = new JLabel(&quot;\\u5269\\u4F59\\u7968\\u6570\\uFF1A&quot;); label.setBounds(153, 41, 62, 15); myFrame.getContentPane().add(label); tf_sytk = new JTextField(); tf_sytk.setColumns(10); tf_sytk.setBounds(220, 38, 54, 21); myFrame.getContentPane().add(tf_sytk); bt_buy = new JButton(&quot;购买&quot;); bt_buy.setBounds(153, 121, 121, 23); myFrame.getContentPane().add(bt_buy); JLabel label_1 = new JLabel(&quot;购买票数：&quot;); label_1.setBounds(153, 96, 62, 15); myFrame.getContentPane().add(label_1); tf_buytk = new JTextField(); tf_buytk.setColumns(10); tf_buytk.setBounds(220, 93, 54, 21); myFrame.getContentPane().add(tf_buytk); bt_add = new JButton(&quot;添加新票&quot;); bt_add.setBounds(10, 121, 130, 23); myFrame.getContentPane().add(bt_add); JLabel label_2 = new JLabel(&quot;出发地&quot;); label_2.setBounds(10, 41, 62, 15); myFrame.getContentPane().add(label_2); tf_start = new JTextField(); tf_start.setColumns(10); tf_start.setBounds(77, 38, 63, 21); myFrame.getContentPane().add(tf_start); JLabel label_2_1 = new JLabel(&quot;目的地&quot;); label_2_1.setBounds(10, 69, 62, 15); myFrame.getContentPane().add(label_2_1); tf_finish = new JTextField(); tf_finish.setColumns(10); tf_finish.setBounds(77, 66, 63, 21); myFrame.getContentPane().add(tf_finish); JLabel label_2_2 = new JLabel(&quot;核定票数：&quot;); label_2_2.setBounds(10, 96, 62, 15); myFrame.getContentPane().add(label_2_2); tf_hdtk = new JTextField(); tf_hdtk.setColumns(10); tf_hdtk.setBounds(77, 93, 63, 21); myFrame.getContentPane().add(tf_hdtk); JButton bt_del = new JButton(&quot;删除&quot;); bt_del.setBounds(153, 9, 121, 23); myFrame.getContentPane().add(bt_del); // 设置窗体关闭确认，关闭窗体时结束进程 myFrame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE); // 设置关闭窗体时什么也不做 myFrame.addWindowListener(new WindowAdapter() { // 配置窗体监听器，如果窗体关闭，执行命令 public void windowClosing(WindowEvent w) { System.exit(0); } }); int[][] tk = new int [100][2]; tk[0][0] = 50; tk[0][1] = 30; tk[1][0] = 30; tk[1][1] = 100; tf_sytk.setText(String.valueOf(tk[0][0])); tf_price.setText(String.valueOf(tk[0][1])); ItemListener a = new ItemListener() { //定义下拉列表监视器 public void itemStateChanged(ItemEvent e) { if (e.getStateChange() == e.SELECTED) { //定义为执行一次 tf_sytk.setText(String.valueOf(tk[cb.getSelectedIndex()][0])); tf_price.setText(String.valueOf(tk[cb.getSelectedIndex()][1])); } } }; cb.addItemListener(a); ActionListener b = new ActionListener() { public void actionPerformed(ActionEvent e) { boolean eq = true; if (e.getSource() == bt_add) { try { if (tf_start.getText().equals(tf_finish.getText())) { JOptionPane.showMessageDialog(null, &quot;出发地和目的地不能相同！&quot;); tf_start.setText(&quot;&quot;); tf_finish.setText(&quot;&quot;); } else { String str = tf_start.getText() + &quot; → &quot; + tf_finish.getText(); for (int i = 0; i &lt; cb.getItemCount(); i++) { if (str.equals(cb.getItemAt(i))) { eq = false; break; } } if (eq) { tk[cb.getItemCount()][0] = Integer.parseInt(tf_hdtk.getText()); tk[cb.getItemCount()][1] = Integer.parseInt(tf_price.getText()); cb.addItem(str); cb.setSelectedIndex(cb.getItemCount()-1); tf_hdtk.setText(&quot;&quot;); tf_start.setText(&quot;&quot;); tf_finish.setText(&quot;&quot;); JOptionPane.showMessageDialog(null, &quot;添加成功&quot;); } else { JOptionPane.showMessageDialog(null, &quot;车程已经存在！&quot;); tf_hdtk.setText(&quot;&quot;); tf_price.setText(&quot;&quot;); tf_start.setText(&quot;&quot;); tf_finish.setText(&quot;&quot;); } } } catch (Exception e2) { if (tf_start.getText().length() == 0 || tf_finish.getText().length() == 0) { JOptionPane.showMessageDialog(null, &quot;出发地和目的地都不能为空！&quot;); } else { JOptionPane.showMessageDialog(null, &quot;票数和单价都必须为数值且不能为空！&quot;); } } } if (e.getSource() == bt_del) { if (cb.getSelectedIndex() == cb.getItemCount() - 1) { cb.removeItemAt(cb.getSelectedIndex()); } else { for (int i = cb.getSelectedIndex(); i &lt; cb.getItemCount() - 1; i++) { tk[i][0] = tk[i+1][0]; tk[i][1] = tk[i+1][1]; } cb.removeItemAt(cb.getSelectedIndex()); } } if (e.getSource() == bt_buy) { try { int nums = Integer.parseInt(tf_buytk.getText()); int price = tk[cb.getSelectedIndex()][1]; if (nums == 0) { JOptionPane.showMessageDialog(null, &quot;购票数不可为0！&quot;); } else if (nums &lt;= tk[cb.getSelectedIndex()][0] &amp;&amp; tk[cb.getSelectedIndex()][0] &gt; 0) { tk[cb.getSelectedIndex()][0] = tk[cb.getSelectedIndex()][0] - nums; JOptionPane.showMessageDialog(null, &quot;购票成功，共&quot; + nums *price + &quot;元!&quot;); } else if (tk[cb.getSelectedIndex()][0] == 0) { JOptionPane.showMessageDialog(null, &quot;抱歉，此车程已经售罄！&quot;); } else { JOptionPane.showMessageDialog(null, &quot;抱歉，您购买的票数超过了库存！&quot;); } tf_sytk.setText(String.valueOf(tk[cb.getSelectedIndex()][0])); } catch (Exception e2) { JOptionPane.showMessageDialog(null, &quot;购买票数不可为空&quot;); } } } }; bt_add.addActionListener(b); bt_del.addActionListener(b); bt_buy.addActionListener(b); }} 打包后的.jar可执行文件 小结这题没有难度，算是Swing的练手，虽然没有人用这个东西了，但生活的意义就是没有意义不是么。","link":"/posts/45713/"}],"tags":[{"name":"HADOOP","slug":"HADOOP","link":"/tags/HADOOP/"},{"name":"分布式","slug":"分布式","link":"/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"踩坑","slug":"踩坑","link":"/tags/%E8%B8%A9%E5%9D%91/"},{"name":"Cloudflare","slug":"Cloudflare","link":"/tags/Cloudflare/"},{"name":"CDN","slug":"CDN","link":"/tags/CDN/"},{"name":"域名","slug":"域名","link":"/tags/%E5%9F%9F%E5%90%8D/"},{"name":"Vercel","slug":"Vercel","link":"/tags/Vercel/"},{"name":"重定向","slug":"重定向","link":"/tags/%E9%87%8D%E5%AE%9A%E5%90%91/"},{"name":"页面规则","slug":"页面规则","link":"/tags/%E9%A1%B5%E9%9D%A2%E8%A7%84%E5%88%99/"},{"name":"SSL","slug":"SSL","link":"/tags/SSL/"},{"name":"Hello World","slug":"Hello-World","link":"/tags/Hello-World/"},{"name":"LINUX","slug":"LINUX","link":"/tags/LINUX/"},{"name":"SHELL","slug":"SHELL","link":"/tags/SHELL/"},{"name":"Latex","slug":"Latex","link":"/tags/Latex/"},{"name":"排版","slug":"排版","link":"/tags/%E6%8E%92%E7%89%88/"},{"name":"数学建模","slug":"数学建模","link":"/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"MATLAB","slug":"MATLAB","link":"/tags/MATLAB/"},{"name":"上帝的笔误","slug":"上帝的笔误","link":"/tags/%E4%B8%8A%E5%B8%9D%E7%9A%84%E7%AC%94%E8%AF%AF/"},{"name":"电影","slug":"电影","link":"/tags/%E7%94%B5%E5%BD%B1/"},{"name":"悬疑","slug":"悬疑","link":"/tags/%E6%82%AC%E7%96%91/"},{"name":"剧情","slug":"剧情","link":"/tags/%E5%89%A7%E6%83%85/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"月记","slug":"月记","link":"/tags/%E6%9C%88%E8%AE%B0/"},{"name":"甲流","slug":"甲流","link":"/tags/%E7%94%B2%E6%B5%81/"},{"name":"新冠","slug":"新冠","link":"/tags/%E6%96%B0%E5%86%A0/"},{"name":"思考","slug":"思考","link":"/tags/%E6%80%9D%E8%80%83/"},{"name":"健身","slug":"健身","link":"/tags/%E5%81%A5%E8%BA%AB/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"复盘","slug":"复盘","link":"/tags/%E5%A4%8D%E7%9B%98/"},{"name":"年终总结","slug":"年终总结","link":"/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"name":"计划","slug":"计划","link":"/tags/%E8%AE%A1%E5%88%92/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"小米平板5","slug":"小米平板5","link":"/tags/%E5%B0%8F%E7%B1%B3%E5%B9%B3%E6%9D%BF5/"},{"name":"pad","slug":"pad","link":"/tags/pad/"},{"name":"刷机","slug":"刷机","link":"/tags/%E5%88%B7%E6%9C%BA/"},{"name":"手写笔","slug":"手写笔","link":"/tags/%E6%89%8B%E5%86%99%E7%AC%94/"},{"name":"win10","slug":"win10","link":"/tags/win10/"},{"name":"镜像","slug":"镜像","link":"/tags/%E9%95%9C%E5%83%8F/"},{"name":"USB","slug":"USB","link":"/tags/USB/"},{"name":"wsl","slug":"wsl","link":"/tags/wsl/"},{"name":"woa","slug":"woa","link":"/tags/woa/"},{"name":"豆瓣","slug":"豆瓣","link":"/tags/%E8%B1%86%E7%93%A3/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"爬虫","slug":"爬虫","link":"/tags/%E7%88%AC%E8%99%AB/"},{"name":"作业","slug":"作业","link":"/tags/%E4%BD%9C%E4%B8%9A/"},{"name":"课综","slug":"课综","link":"/tags/%E8%AF%BE%E7%BB%BC/"},{"name":"Scrapy","slug":"Scrapy","link":"/tags/Scrapy/"},{"name":"二维数组","slug":"二维数组","link":"/tags/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/"}],"categories":[{"name":"笔记","slug":"笔记","link":"/categories/%E7%AC%94%E8%AE%B0/"},{"name":"日常","slug":"日常","link":"/categories/%E6%97%A5%E5%B8%B8/"},{"name":"生活","slug":"生活","link":"/categories/%E7%94%9F%E6%B4%BB/"},{"name":"编程","slug":"编程","link":"/categories/%E7%BC%96%E7%A8%8B/"},{"name":"Python","slug":"编程/Python","link":"/categories/%E7%BC%96%E7%A8%8B/Python/"},{"name":"Java","slug":"编程/Java","link":"/categories/%E7%BC%96%E7%A8%8B/Java/"}],"pages":[{"title":"关于 &amp; 留言板","text":"我：一个普通人， 多赢主义者， 经常违背自己。 此网站：记录学习（吹水）的地方。 其他：友链看心情。","link":"/about/index.html"},{"title":"archive","text":"","link":"/archive/index.html"}]}