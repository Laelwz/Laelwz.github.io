{"pages":[{"title":"关于 &amp; 留言板","text":"我：一个普通人， 多赢主义者， 经常违背自己。 此网站：记录学习（吹水）的地方。 其他：友链看心情。","link":"/about/index.html"},{"title":"archive","text":"","link":"/archive/index.html"}],"posts":[{"title":"Hello World","text":"Hello World ！ Hello World ！Hello World ！ Hello World ！Hello World ！","link":"/posts/63534/"},{"title":"Hadoop伪分布式部署踩坑","text":"在上Hadoop分布式存储课时首先让我们部署一个简单的伪分布式存储系统，但是实机安装和机房老师已经弄好的快照还是十分不同的，踩了一些坑。 1. 启动namenode时，自动关闭查询 log (日志) 可以发现如下错误代码： 123hadoop-root-namenode-localhost.localdomain.logCall From hadoop to null:0 failed on socket exception:java.net.SocketException: Unresolved address 解决方法： 修改etc/hadoop目录下的core-site.xml，把hdfs://hadoop:9000中的hadoop改为本机ip。 或在namenode主机 hosts (主机) 将hadoop代理到本机ip。 2. namenode启动成功，关闭防火墙后无法访问50070端口解决方法： 先查看端口开放情况 netstat -ant 50070端口显示为 127.0.0.1:50070 将绑定IP改为0.0.0.0，而不是本地回环IP，这样，就能够实现外网访问本机的50070端口。 在hdfs-site.xml中修改添加如下代码： 123456hdfs-site.xml&lt;property&gt; &lt;name&gt;dfs.http.address&lt;/name&gt; &lt;value&gt;0.0.0.0:50070&lt;/value&gt;&lt;/property&gt;","link":"/posts/942/"},{"title":"Linux 输入&#x2F;输出重定向","text":"Linux 下输入/输入重定向简析 一个命令通常都会打开三个文件，默认使用文件描述符0, 1, 2来指代这个三个文件 123stdin 0 #标准输入流 （键盘）stdout 1 #标准输出流 （终端）stderr 2 #标准错误输出流 （终端） 输出重定向command 为任意命令，file为任意文件 12345command &gt; file #将标注输出重定向（写入）到 file 里command 1&gt; file #将标准输出重定向到 file 里（与上式一致）command 2&gt; file #将错误输出重定向到 file 里command &amp;&gt; file #将标准输出与错误输出一起重定向到 file 里command &gt;&gt; file #将标准输出追加到file中 例：标注输出至文件 1234567$ ls #展示当前目录test1 test2 test3$ ls &gt; test3 #将当前目录展示输出到test3文件中$ cat test3 #查看test3文件内容test1test2test3 例：错误输出至文件 123456789101112$ lstest1 test2 test3$ cat testxcat: testx: 没有那个文件或目录$ cat testx 2&gt;&gt; test3 #追加错误输出至test3文件中$ cat testcat: test: 没有那个文件或目录$ cat test3test1test2test3cat: testx: 没有那个文件或目录 例：标准输出与错误输出一同写入文件 12345678$ cat test2$ cat testxxxx test3 &amp;&gt; test2$ cat test2cat: testxxxx: 没有那个文件或目录test1test2test3cat: testx: 没有那个文件或目录 输入重定向xxx 为标签 12command &lt; file #重定向标准输入command &lt;&lt; xxx #多行输入 例：标注输入与命令读取的异同 123456$ head -v test1 #head -v展示文件内容以及文件名称==&gt; test1 &lt;==123$ head -v &lt; test1 #使用标准输入读取==&gt; 标准输入 &lt;==123 可见使用标准输入时，文件名称变为了标准输入。 例：标准输入实现多行输入 1234567891011$ head -v &lt;&lt;abc&gt; 123&gt; 123&gt; asd&gt; abc==&gt; 标准输入 &lt;==123123asd$ cat test1123 以上命令中，设定 abc 为结束标签，在多行输入结束时，输入abc，即识别标签并结束输入。 参考 https://gwaslab.com/2021/11/28/linux-redirection/","link":"/posts/59339/"},{"title":"Latex笔记","text":"记录一些Latex排版的技巧和坑。 对列表中新的段落增加缩进12\\usepackage{enumitem} %导言下加入\\setlist[enumerate]{listparindent=\\parindent} 表格中单元格自动换行1234567891011121314\\begin{table}[H] \\centering \\setlength{\\tabcolsep}{12mm}{ %设置列表宽度 \\caption{累积贡献率表}\\label{table_4-3} \\begin{tabular}{cp{11.8cm}} % cp{超出该值自动换行} 好像仅支持三线表，表格就得手动了。 \\toprule &amp; \\hspace{10em}部分药材编号 \\\\ \\midrule 1类 &amp; 1、17、32、35 39、40、45、46 \\\\ 2类 &amp; 2、5、8、11、13、15、16、18、22、24、25、26、27、28、29、33，34、36、37、38、43、44、47、49 \\\\ 3类 &amp; 1、4、6、7、9、10、12、14 19、20、21、23、24、30、31、35、36、37、41、42、48、50 \\\\ \\bottomrule \\end{tabular}}\\end{table} 为表格添加注释1234567891011121314151617181920\\begin{table}[H] \\centering \\caption{分波段方差分析表}\\label{table_4-4} \\setlength{\\tabcolsep}{17mm}{ %设定宽度一定要包在tabular外面一层 \\begin{tabular}{ccc} \\toprule 波段 &amp; F value &amp; P value \\\\ \\midrule $[901-950]$ &amp; 192.4 &amp; &lt;2e-16*** \\\\ %表格中[]中括号要加数学数学公式才能打出来 $[951-1000]$ &amp; 132.9 &amp; &lt;2e-16*** \\\\ $[1001-1050]$ &amp; 46.14 &amp; 1.13E-1*** \\\\ $[1051-1200]$ &amp; 78.06 &amp; &lt;2e-16*** \\\\ ... &amp; ... &amp; ... \\\\ \\bottomrule \\end{tabular}} \\begin{tablenotes} \\footnotesize \\item 注：*、**、***分别代表0．1、0，05、0.01的显著性水平 \\end{tablenotes}\\end{table} 图片并列排放12345678910111213\\begin{figure}[H] \\centering \\begin{minipage}[t]{0.48\\textwidth} %设定宽度 \\centering \\includegraphics[width=.8\\textwidth]{figure_4-24.jpg} \\caption{不同种类药材光谱数据均值曲线}\\label{figure_4-24} \\end{minipage} \\begin{minipage}[t]{0.48\\textwidth} \\centering \\includegraphics[width=.8\\textwidth]{figure_4-25.jpg} \\caption{不同种类药光谱数据标准差曲线}\\label{figure_4-25} \\end{minipage}\\end{figure} 图表编号混乱可以重置计数器1\\setcounter{table}{0} %重置table计数器 行内公式大小修正可以用的字体有: 1234\\displaystyle 标准\\textstyle 行内\\scriptstyle 第一层上下标\\scriptscriptstyle 第二层上下标 案例： 1$P=\\displaystyle{\\frac{T P}{T P+F P}}$ % \\displaystyle在数学公式符号内将需要修正大小的数学公式括起来 表格中单元格合并合并一行多列：\\multicolumn{cols}{pos}{text} 合并多行一列：\\multirow{rows}{width}{text} 123456789101112131415161718192021\\begin{table}[H] \\centering \\setlength{\\tabcolsep}{5.62mm}{ \\caption{累积贡献率表}\\label{table_5-3} \\begin{tabular}{cccccc} \\toprule 数据 &amp; 模型 &amp; 召回率 &amp; 精确率 &amp; 准确率 &amp; F1值 \\\\ \\midrule %\\multirow命令所覆盖的单元格需要用~代替 \\multirow{6}*{原始数据} &amp; SVC &amp; 0.869 &amp; 0.876 &amp; 0.871 &amp; 0.870 \\\\ ~ &amp; RF &amp; 0.500 &amp; 0.538 &amp; 0.535 &amp; 0.506 \\\\ ~ &amp; XGBoost &amp; 0.566 &amp; 0.599 &amp; .588 &amp; 0.568 \\\\ ~ &amp; GBDT &amp; 0.502 &amp; 0.520 &amp; 0.529 &amp; 0.500 \\\\ ~ &amp; LightGBM &amp; 0.570 &amp; 0.604 &amp; 0.600 &amp; 0.571 \\\\ ~ &amp; MLP &amp; 0.514 &amp; 0.538 &amp; 0.550 &amp; 0.509 \\\\ \\multirow{3}*{PCA降维数据} &amp; SVC &amp; 0.876 &amp; 0.869 &amp; 0.870 &amp; 0.871 \\\\ ~ &amp; RF &amp; 0.538 &amp; 0.500 &amp; 0.506 &amp; 0.535 \\\\ ~ &amp; XGBoost &amp; 0.599 &amp; 0. .566 &amp; 0.568 &amp; 0.588 \\\\ \\bottomrule \\end{tabular}}\\end{table} 表格续前表12345678910111213141516171819202122232425262728293031323334353637383940414243\\begin{center} \\setlength{\\tabcolsep}{5.62mm}{ \\begin{longtable}{cccccc} \\caption{基于机器学习方法的药材产地鉴别模型比较}\\\\ \\label{revenuepatternexplain} \\\\ \\endfirsthead %此命令以上为第一页表头 \\toprule %一条线 \\endhead %此命令以上为续前表的表头 数据 &amp; 模型 &amp; 召回率 &amp; 精确率 &amp; 准确率 &amp; F1值 \\\\ \\midrule \\multirow{7}*{原始数据} &amp; SVC &amp; 0.869 &amp; 0.876 &amp; 0.871 &amp; 0.870 \\\\ ~ &amp; RF &amp; 0.500 &amp; 0.538 &amp; 0.535 &amp; 0.506 \\\\ ~ &amp; XGBoost &amp; 0.566 &amp; 0.599 &amp; .588 &amp; 0.568 \\\\ ~ &amp; GBDT &amp; 0.502 &amp; 0.520 &amp; 0.529 &amp; 0.500 \\\\ ~ &amp; LightGBM &amp; 0.570 &amp; 0.604 &amp; 0.600 &amp; 0.571 \\\\ ~ &amp; MLP &amp; 0.514 &amp; 0.538 &amp; 0.550 &amp; 0.509 \\\\ \\multirow{7}*{PCA降维数据} &amp; SVC &amp; 0.876 &amp; 0.869 &amp; 0.870 &amp; 0.871 \\\\ ~ &amp; RF &amp; 0.538 &amp; 0.500 &amp; 0.506 &amp; 0.535 \\\\ ~ &amp; XGBoost &amp; 0.599 &amp; 0. .566 &amp; 0.568 &amp; 0.588 \\\\ ~ &amp; GBDT &amp; 0.539 &amp; 0.498 &amp; 0.500 &amp; 0.541 \\\\ ~ &amp; LighGBM &amp; 0.516 &amp; 0.473 &amp; 0.475 &amp; 0.512 \\\\ ~ &amp; MLP &amp; 0.521 &amp; 0488 &amp; 0.482 &amp; 0.521 \\\\ \\multirow{7}*{原始数据} &amp; SVC &amp; 0.914 &amp; 0.921 &amp; 0.913 &amp; 0.916 \\\\ ~ &amp; RF &amp; 0.915 &amp; 0.929 &amp; 0.927 &amp; 0.915 \\\\ ~ &amp; XGBoost &amp; 0.970 &amp; 0.974 &amp; 0.970 &amp; 0.920 \\\\ ~ &amp; GBDT &amp; 0.881 &amp; 0.889 &amp; 0.900 &amp; 0.883 \\\\ ~ &amp; LightGBM &amp; 0.964 &amp; 0.968 &amp; 0.964 &amp; 0.964 \\\\ ~ &amp; MLP &amp; 0.813 &amp; 0.839 &amp; 0.828 &amp; 0.817 \\\\ \\multirow{7}*{原始数据} &amp; SVC &amp; 0.861 &amp; 0.868 &amp; 0.863 &amp; 0.860 \\\\ ~ &amp; RF &amp; 0.869 &amp; 0.882 &amp; 0.857 &amp; 0.861 \\\\ ~ &amp; XGBoost &amp; 0.915 &amp; 0.935 &amp; 0.921 &amp; 0.920 \\\\ ~ &amp; GBDT &amp; 0.793 &amp; 0.834 &amp; 0.816 &amp; 0.799 \\\\ ~ &amp; LightGBM &amp; 0.923 &amp; 0.932 &amp; 0.925 &amp; 0.923 \\\\ ~ &amp; MLP &amp; 0.812 &amp; 0.820 &amp; 0.815 &amp; 0.809 \\\\ \\multirow{7}*{原始数据} &amp; SVC &amp; 0.824 &amp; 0.835 &amp; 0825 &amp; 0.823 \\\\ ~ &amp; RF &amp; 0.834 &amp; 0.871 &amp; 0.853 &amp; 0.841 \\\\ ~ &amp; XGBoost &amp; 0.881 &amp; 0.897 &amp; 0.887 &amp; 0.884 \\\\ ~ &amp; GBDT &amp; 0.814 &amp; 0.835 &amp; 0.822 &amp; 0.822 \\\\ ~ &amp; LightGBM &amp; 0.850 &amp; 0.866 &amp; 0.854 &amp; 0.853 \\\\ ~ &amp; MLP &amp; 0.787 &amp; 0.795 &amp; 0.790 &amp; 0.785 \\\\ \\bottomrule \\end{longtable}}\\end{center} 简单三线表1234567891011121314\\begin{table}[H] \\centering \\setlength{\\tabcolsep}{12mm}{ %设置列表宽度 \\caption{各管线费用}\\label{table_1} \\begin{tabular}{cc} \\toprule 管线 &amp; 铺设费用 \\\\ \\midrule A炼油厂 &amp; 5.6万元/km \\\\ B炼油厂 &amp; 6.0万元/km \\\\ 共用管线 &amp; 7.2万元/km \\\\ \\bottomrule \\end{tabular}}\\end{table} 公式中实现等号对齐123456\\begin{equation} \\begin{split} f(x, y, m) = &amp; P_{1} \\sqrt{x^{2}+(y-a)^{2}}+P_{2} \\sqrt{(c-x)^{2}+(b-m-y)^{2}} \\\\ &amp; +\\left(Q+P_{2}\\right) \\sqrt{(l-c)^{2}+m^{2}}+ P^{\\prime} y \\end{split}\\end{equation}\\label{eqx1} 引用文献实现超链接1\\cite{bib:seven} 并列图片123456789101112131415\\end{table}\\begin{figure}[H] \\centering \\caption{LDA与SVM在近红外光谱数据中的混淆矩阵示意图}\\label{LDA_SVM} \\begin{minipage}[t]{0.48\\textwidth} \\centering \\includegraphics[width=.9\\textwidth]{近红外_LDA.eps} \\caption*{LDA} \\end{minipage} \\begin{minipage}[t]{0.48\\textwidth} \\centering \\includegraphics[width=.9\\textwidth]{近红外_SVM.eps} \\caption*{SVM} \\end{minipage}\\end{figure}","link":"/posts/59143/"},{"title":"MATLAB基于问题的整数线性规划","text":"这几天做题遇到了较为复杂的规划问题，在想能不能用MATLAB实现像LINGO那样的偏向用户输入的编写方法，而非MATLAB矩阵式的，最终实现了基于问题的求解代码。 \\begin{equation} A = \\begin{bmatrix} a & b \\\\ c & c \\end{bmatrix} \\end{equation} \\begin{equation}\\ \\begin{array}{c} \\begin{aligned} \\max \\quad \\mathrm{E} = \\frac{Q-F-T}{F+T} \\times 100 \\% \\\\ \\end{aligned} \\\\ \\begin{aligned} s \\cdot t\\left\\{\\begin{array}{l} \\frac{\\sum_{i = 1}^{8} b_{i} \\cdot x_{i}}{L} \\leq 2.28 \\\\ m_{i} \\leq x_{i} \\leq M_{i} \\\\ \\sum_{i = 1}^{11} x_{i} \\cdot r_{i} \\geq 0.7069 \\cdot \\theta \\quad 0 \\quad 0","link":"/posts/25548/"},{"title":"MATLAB聚类评价指标计算","text":"发现网上很少关于MATLAB聚类评价指标如CHI、DBI以及轮廓系数的计算，其实使用一个内置函数就搞定了，但是看到很多人在重复造轮子。 evalclusters()函数用法： eva= evalclusters(data,clust,'xxx'); data：不带标签的原始数据。clust：聚类后的标签，参数可以是字符串或者矩阵，字符串了话就要写matlab规定的聚类算法，比如’kmeans’。如果你用的不是matlab自带的聚类算法去聚类的，而是想评估自己写的聚类算法性能，那么clust就填写你聚类结果的标签矩阵 Label (标签) 就行了，比如你的数据data是NM的，N是样本个数，M是特征维数。那么标签矩阵 Label (标签) 就是N1的矩阵，代表聚类后每个样本的标签，这样就可以输出评估结果了。‘xxx’：可以选择四种评价指标：’CalinskiHarabasz’ | ‘DaviesBouldin’ | ‘ gap (差距) ’ | ‘silhouette’‘CalinskiHarabasz’: Calinski-Harabasz index (指数) (CHI，越大越好)‘DaviesBouldin’: Davies-Bouldin index (指数) (用的最多，越小越好)‘ gap (差距) ’: gap (差距) statistic (统计) (越大越好)‘silhouette’: silhouette coefficient (SC，轮廓系数，越大越好) MATLAB代码附件一.xlsx 代码12345678910111213141516171819202122232425clearclc% kmeans聚类中有效性评价指标测试% 问题一Data = xlsread('附件1.xlsx');% 数据标准化处理Data1 = Data(2:426,2:3349);% 建立空数组arzs = zscore(Data1);% 使用kmeans聚类函数[ind,C]=kmeans(arzs,4);data = Data1;label = ind; % 真实标签eva_DBI_1= evalclusters(data,label,'DaviesBouldin');eva_SC_1= evalclusters(data,label,'silhouette');eva_CHI_1= evalclusters(data,label,'CalinskiHarabasz');% 这三个变量即为结果DBI_1 = eva_DBI_1.CriterionValues; % 越小越好SC_1 = eva_SC_1.CriterionValues; % 越大越好CHI_1 = eva_CHI_1.CriterionValues; % 越大越好 运行结果123DBI_1 = 0.614370044401414; % 越小越好SC_1 = 0.724336668984950; % 越大越好CHI_1 = 1.298586390458516e+03; % 越大越好 参考 https://www.mathworks.com/help/stats/evalclusters.html https://www.cnblogs.com/kailugaji/p/16169796.html","link":"/posts/302112/"},{"title":"Matlab数学建模笔记","text":"记录使用Matlab解决数学建模问题中遇到的坑。 数据拟合[P,S,mu] = polyfit(x,y,n) 给出在最小二乘一一下最佳拟合系数 函数根据采样点x, y，产生一个n次多项式P及其在采样点的误差向量S x, y为等长向量 P为长度为m+1的向量 图片X轴过小12345678910XX = [170 120 180 200 190 220; 120 100 110 180 170 180; 70 50 80 100 95 120];[Data, TextData] = xlsread('sj.xlsx');bar(Data,'stacked')set(gca,'xtick',1:31,'xticklabel',[&quot;北京&quot;,&quot;天津&quot;,&quot;河北&quot;,&quot;山西&quot;,&quot;内蒙古&quot;,&quot;辽宁&quot;,&quot;吉林&quot;,&quot;黑龙江&quot;,&quot;上海&quot;,&quot;江苏&quot;,&quot;浙江&quot;,&quot;安徽&quot;,&quot;福建&quot;,&quot;江西&quot;,&quot;山东&quot;,&quot;河南&quot;,&quot;湖北&quot;,&quot;湖南&quot;,&quot;广东&quot;,&quot;广西&quot;,&quot;海南&quot;,&quot;重庆&quot;,&quot;四川&quot;,&quot;贵州&quot;,&quot;云南&quot;,&quot;西藏&quot;,&quot;陕西&quot;,&quot;甘肃&quot;,&quot;青海&quot;,&quot;宁夏&quot;,&quot;新疆&quot;])% 使用set命令的'xtick',1:31参数更改X轴显示legend(&quot;食品&quot;,&quot;衣着&quot;,&quot;设备&quot;,&quot;医疗&quot;,&quot;交通&quot;,&quot;教育&quot;,&quot;居住&quot;,&quot;杂项&quot;)xlabel('不同城市的八个方面');ylabel('一年的消费情况');grid ontitle('31个城市的不同消费情况') 高斯平滑处理1234567%高斯数据平滑处理，高斯滤波b = smoothdata(a,&quot;gaussian&quot;,500);x_gj1=b(:,1);z_gj1=b(:,2);x_a=a(:,1);z_a=a(:,2);plot(x_gj1,z_gj1,x_a,z_a)","link":"/posts/53370/"},{"title":"MySQL学习笔记","text":"期末了，梳理一遍MySQL，防止挂科。 数据库的管理数据库的创建例：创建一个名称为mysqltest的数据库 1create database if not exists mysqltest; 例：创建教务管理数据库teaching，并指定字符集为gb2312，校对原则为gb2312_chinese_ci。 123create database teaching default character set gb2312default collate gb2312_chinese_ci; 打开并设置数据库例：打开前面创建的teaching数据库，设置其为当前默认的数据库 1use teaching; 修改数据库参数例：将前面创建的teaching的默认字符集设置为UTF8，校对规则为utf8_unicode_ci 123alter database teachingdefault character set utf8default collate utf8_unicode_ci; 查看字符集与校对规则12show variables like ‘char%’;show variables like ‘collation_%; 显示数据库结构1show create database teaching; 删除数据库例：删除前面创建的teaching数据库 1drop database teaching; 数据表的管理数据表的创建例：创建学生成绩管理系统数据库中的学生表： 1234567create table student ( studentno char(8), name varchar(10), sex enum('男','女'), birthday date, classno char(7)); 数据表的修改添加列（字段）123alter table 表名add 新列名 数据类型[约束条件] [ first | after 已存在列名]; 例：在student表中添加一个电话字段（tel），将其放到sex字段之后： 12alter table student add tel char(11) after sex; 修改列例：修改student表中的tel字段的列名为Email，数据类型为varchar(30); 1alter table student change tel Email varchar(30); 删除列例：删除student表中的Email列; 1alter table student drop Email; 修改表名称例：将student表重命名为stu: 1alter table student rename to stu; 修改列的数据类型和位置例：修改student表中的Email字段的数据类型为varchar(20)，将其移动到birthday字段之后; 12alter table student modify Email varchar(20) after birthday; 删除表例：删除stu表; 1drop table stu; 插入数据例：给教师表添加两条记录(‘T01’,‘张三’和‘T02’,‘李四’) 1234insert into teacher(teacherno,name) values ('T01','张三');insert into teacher values('T02','李四');- 或insert into teacher values(‘T01’,‘张三’),('T02','李四'); 例：利用set子句向teacher表插入数据 1insert into teacher set name='王五', teacherno='T03'; 修改数据例：给将学号为61130702的学生姓名修改为孙乐然 1update student set name='孙乐然' where studentno='61130702'; 删除数据例：将成绩表中C02成绩最低的1个学生的信息删除 12delete from score where courseno='C02'order by finalscore limit 1; 例：清除成绩表中的所有信息 1delete from score; 表约束 非空约束 null：字段值可以为空 not null：字段值不允许为空 例：创建教师表，设置教师编号为非空约束 1234create table teacher(teacherno char(3) not null,name varchar(10)); 例：修改教师表，设置姓名列为非空约束 1alter table teacher modify name varchar(10) not null 例：修改教师表，去除姓名列的非空约束 1alter table teacher modify name varchar(10); 主键约束 主键列的数据唯一，不允许为空，主键唯一标识表中一条记录。 一张表中最多一个主键约束。 主键可以是一个字段，也可以是多个字段。 例：创建教师表，设置教师编号为主键约束 1234create table teacher( teacherno char(3) primary key, name varchar(10)); 例：修改教师表，去除主键约束 1alter table teacher drop primary key; 例：修改教师表，设置教师编号列为主键约束 1alter table teacher modify teacherno char(3) primary key; 唯一约束 该列唯一，允许为空 一个数据表只能创建一个主键，但可以有多个唯一约束 例：创建教师表，设置教师编号为唯一约束 1234create table teacher( teacherno char(3) unique, name varchar(10)); 例：修改教师表，去除唯一约束 1alter table teacher drop index teacherno; 例：修改教师表，设置教师编号列为唯一约束 1alter table teacher modify teacherno char(3) unique; 默认约束 指定某列的默认值 例：创建学生表student，设置性别的默认约束为男 1234567create table student( studentno char(8), name varcahr(10), sex enum('男', '女') default '男', brithday date, classNo char(7)); 例：删除学生表的默认约束 1alter table student modify sex enum('男'， '女'); 例：对学生表student的sex列，修改默认约束为男 1alter table student modify sex enum('男', '女') default '男'; 外键约束 建立子表与父表的关联，保证数据一致性，父表中信息更新，子表中对应的信息相应改变。 原则：必须依赖于已存在的父表的主键 外键可以为空值 例：创建班级表，表中的teacherno字段为外键（主表是teacher表） 1234567create table class ( classno char(7) primary key, name varchar(20), teacherno char(3), foreign key(teacherno) references teacher(teacherno)); 例：删除班级表teacherno字段上的外键约束 1alter table class drop foreign key teacherno; 例：在班级表的teacherno字段上添加外键约束 1alter table class add foreign key (teacherno) references teacher(teacherno); 检查约束 限定列的数据值范围 例：创建成绩表，设置成绩字段的取值范围是0～100 123456create table score( courseno char(3), studentno char(8), finalscore tinyint default 0 check(finalscore &gt;= 0 &amp;&amp; score &lt;= 100)); 例：删除成绩表上的检查约束 1alter table score drop check score_chk_1; 例：在成绩表的成绩字段添加检查约束（&gt;=0） 1alter table score add check(finalscore &gt;= 0); 简单查询distinct 消除重复行 distinct子句可以消除查询结果中的重复行 例：查找所有参加考试的同学的学号，重复的行只出现一次 1select distinct stuno from tbl_score; where in 判断过滤 where设置了查询条件 in关键字可以判断某个字段的值是否在集合中 查询不在集合中使用not in 多个判断条件使用and连接 例：查询学号为60115101,60115102,60115103,60115104四位同学的成绩 12select * from tbl_score where stuno in(60115101,60115102,60115103,60115104) between and 指定查询范围 排除范围使用not between 例：查询成绩在80—90之间的学号、课程号、成绩 1select * from tbl_score where score between 80 and 90; like 通配符查询 like关键字结合通配符，通过字符串比较来选择符合条件的行 “%” 表示0个或多个字符 “_”表示匹配一个字符 is null 查询空值 查询非空值用 is not null 例：查找成绩表中没有成绩（即成绩为空）的行 1select * from tbl_score where score is null; 聚合函数查询count() count(列名)函数返回非null行的行数 count(*)返回包含null的所有行 sum() 求出某个字段的和 avg() 求出某个字段的平均值 round() 四舍五入 第一个参数是原来的值 第二个参数是小数位数 例：查询每位同学的总分和平均分（四舍五入到1位小数） 1234select stuno, sum(score) as total_score, round(avg(score), 1)from tbl_score group by stuno; max() min() 返回最大值和最小值 查询中的子句order by 对查询结果进行排序 升序：asc，降序：desc 默认升序，null值排最前面，降序则null值排最后 例：查询成绩表中C01课程的成绩，并按成绩降序排列 1select * from tbl_score where courseno='C01' order by score desc; group by 将查询结果按指定字段进行分组 group by与group_concat()函数结合，可以将 每个组中的所有字段值都显示出来 group_concat()的作用是链接字符串 例：使用 GROUP BY 语句 将数据表按名字进行分组，并统计每个人有多少条记录 1select name, count(*) from employee_tbl group by name; with rollup 在分组统计的基础上再进行相同的总体统计 要和group by一起使用，加在最后 having 通常与group by子句结合使用 指定在where子句的筛选后进一步筛选，即group by分组后的再筛选 例：查询选课有2门以上且课程成绩均高于80分的学生的学号及其总成绩（不计算80分以下的），结果按成绩降序排列 123456select stuno as '学号', sum(score) as '总分' from tbl_score where score &gt;= 80 group by stuno having count(*) &gt;= 2 order by sum(score) desc; limit 显示指定序号记录的结果 第一条记录编号为0 第一个参数为开始编号 第二个参数为记录的个数 例：查询成绩表信息，按成绩降序排序，显示前3条记录 1select * from score order by finalscore desc limit 3; 例：查询成绩表信息，按成绩降序排序，显示编号2开始的3条记录 1select * from score order by finalscore desc limit 2,3; 内连接 自然连接运算 为了区分两个表中同名的列，需要对同名的列加上表名做为前缀。 多表（两张以上）查询：先进行两表连接，结果再和第三张表进行连接 例：查询学生的学号、姓名、课程号和成绩。 123select score.stuno, stuname, courseno, score from tbl_score score inner join tbl_student student on student.stuno=score.stuno; 左/右 外连接 左连接 将左表所有值对应右表查询，右表中没有的显示为null 例：查询所有学生的学号、姓名、班级号、班级名称。 123select stuno, stuname, c.classno, classname from tbl_student as s left join tbl_class as c on s.classno=c.classno; 右连接 将右表所有值对应右表查询，左表中没有的显示为null 123select stuno, stuname, c.classno, classname from tbl_student as s right join tbl_class as c on s.classno=c.classno; 合并多个查询结果例：合并姓张和姓李的同学的查询结果 123select * from tbl_student where stuname like '张% ' unionselect * from tbl_student where stuname like '李%'; exists() 在where后用于判断是否存在 返回True或False 例：查询是否存在班级号为‘P601119’的学生，如果存在输出学生信息 12select * from tbl_student where exists(select * from tbl_student where classno='P601119'); 视图例：创建视图course_avg，统计各门课程平均成绩，并按课程名称降序排列 123456create view course_avg as select tbl_course.coursename as 课程名, avg(score) as 平均成绩 from tbl_score inner join tbl_course on tbl_score.courseno= tbl_course.courseno group by tbl_course.courseno order by tbl_course.coursename desc; 变量 系统会话变量以两个@开头 用户会话变量以一个@开头 用户会话变量例：:创建用户会话变量@name，并赋值为“张三” 123set @name=“张三”- 或select @name:=“张三” 局部变量例：定义局部变量myvar，数据类型为int，默认值为100，并赋值60 12declare myvar int default 100;set myvar = 60; 自定义函数例：创建一个名为func_course的函数，返回表course中指定课程号的课程名 1234567delimiter &amp;&amp;create function func_course(c_no char(3))returns varchar(20)begin return(select coname from course where courseno=c_no);end &amp;&amp;delimiter ; IF 条件控制 函数中使用if 例：创建函数exam_if，判断传入的参数如果是10，是则输出1，否则判断是否是20，是则输出2，否则输出3 1234567891011delimiter //create function exam_if(x int)returns intbeginif x=10 then set x=1;elseif x=20 then set x=2;else set x=3;end if;return x;end //delimiter ; 查询中使用if() 例：从成绩表中查询学号为60121901的学生成绩信息,如成绩大于等于80分，显示“通过”，否则显示“未通过” 123select *,if(finalscore&gt;=80,'通过','未通过') as '是否通过' from score where studentno='60121901'; 查询中使用ifnull() 例：从成绩表中查询学号为60241902的学生成绩信息,如成绩为null，显示“没有成绩”，否则显示成绩 1select * ,ifnull(finalscore,'没有成绩') from score where studentno='60241902'; while循环例：定义函数exam_while,求1到n的和 123456789101112delimiter //create function exam_while(n int) returns intbegin declare sum int default 0;declare m int default 1;while m&lt;=n doset sum =sum+m;set m=m+1;end while;return sum;end //delimiter ; 储存过程 无参数 例：创建存储过程proc_stu，从数据库school的student表中检索出所有2001年出生的学生的学号、姓名、出生日期等信息 123456delimiter //create procedure proc_stu()begin select * from student where year(birthday)='2001';end //delimiter ; 有参数 例：创建存储过程stu_score的，统计指定同学的考试门数 1234567delimiter //create procedure stu_scores(in s_no char(8), out count_num int)reads SQL databeginselect count(*) into count_num from score where studentno=s_no;end //delimiter ; 调用：call stu_scores(‘18125121107’, @c_num ); 查看：select @c_num; 触发器 在表数据修改后激活的指令 例：创建一个触发器，当更改表course中某门课的课程号时，同时将score表课程号全部更新 1234567delimiter $$create trigger cno_update after update on course for each rowbegin update score set courseno=new.courseno where courseno=old.courseno;end $$delimiter ; update on 更新后 delete on 删除后 insert 插入后 例：在de_teacher表插入记录前和插入记录后，分别向before_insert和after_insert中插入一条记录 123456789create trigger before_insert before insert on de_teacher for each row insert into bef_after set teacherno =‘t11’, name =‘孙悟空’; create trigger after_insert after insert on de_teacher for each row insert into bef_after set teacherno =‘t22’, name =‘猪八戒’; 用户管理 添加 例：添加两个新用户，用户名zzz,密码zzz001,用户名qqq，密码qqq002 123create user 'zzz'@'localhost'identified by 'zzz001', 'qqq'@'localhost'identified by 'qqq002'; 修改名称为rename 修改密码 例：修改用户kkk的密码为kkk008 1mysqladmin -u kkk -p password &quot;kkk008&quot; 例：更新密码 1mysqladmin -u username -p password &quot;newpassword&quot; 删除用户 例：删除普通用户kkk 1drop user kkk@localhost; 或 12delete from mysql.user where host='localhost' and user='kkk'; 权限管理授予权限例：创建一个新用户zzz,密码为zzz001，用户zzz对所有的数据有查询、插入权限，并授予grant权限 123create user ‘zzz’@‘localhost’identified by 'zzz001'； grant select,insert on *.* to 'zzz'@'localhost' with grant option; 例：查询用户zzz的权限 1show grants for 'zzz'@'localhost' 收回权限例：收回用户zzz的insert权限 1revoke insert on *.* from 'qqq'@'localhost'; 例：收回用户zzz的所有权限 1revoke all privileges,grant option from 'qqq'@'localhost'; 报错处理14181set global log_bin_trust_function_creators=1;","link":"/posts/39805/"},{"title":"《上帝的笔误》疑点分析","text":"看这部电影还是蛮曲折的，两天断断续续的才看完，主要是前半段确实铺垫较多，节奏较慢，后半部分着实精彩，现在来回顾一些关于影片的疑点和思考。 语言带来的大概是语言的问题，我虽看过《看不见的客人》，也看过许多欧洲那些非英语的片子，但是还是打心底对这些小语种感到迷茫。这种感觉就像以前从来不看日本动漫，便对日语有一种奇怪的排斥感，随着接触越来越多，就逐渐适应了。 如同以前第一次看北欧的挪威的片，第一次听到挪威语，叽里呱啦的，此时观看奥里奥尔·保罗这部西班牙语的电影，也是那种好久不见的感受。 题材反转反转再反转，对于经常看悬疑片的我来说已经见怪不怪了（bushi）。不能说精神病院这种题材烂大街，只是在观看之前，我就能够意识到这是一部对精神病有所刻画以及在剧情中会以此为主线基调的电影，所以有了一些准备，后面的反转只能说是意料之中。 不过对于电影的镜头语言我非常喜欢，开场女主坐在车里看向镜头外的观众、被治疗后产生的与前医生 Donadio 的对话的幻象等等场面，都非常令人惊艳。有一种石子落入水滴荡起波澜的感觉，好像随着女主的侦探视角，一步步剥开“事实”，有种《夏日重现》中慎平俯瞰的那味儿。 思考对于女主是否是精神病的问题，我想通过开头私人医生 Donadio 写的信以及结尾私人医生 Donadio 直接跳脸对峙时女主的微表情，不难看出这是高智商精神病女主在最后计划败露的不甘与害怕。 所谓的“事实”，是女主用各个谎言的连环自证，得出的一个她能离开精神病院的结论。 关于故事我不想再赘述回顾，讲一些别人可能没注意到，我觉得可以证明女主有问题的疑点： 在纵火那段剧情中，女主作案前寻求精神病人们的帮助，所有人都点头同意了，虽然说他们是精神病人，思维也许和正常人有所偏差，但对于没怎么相处的女主，却都表现出一副乐意帮助的态度，我觉得这可能是女主曾经在这所精神病院呆过的原因。 电影故事分为三条事件线，第一条是女主调查杀人事件，第二条是侏儒死亡事件，第三条是女主制造动乱事件。 侏儒死亡事件感觉和主线无关，但可以剧情中可以看到女主自然的接受了作为双胞胎母亲，以及在教堂时双胞胎之一和女主的对视，不难让观众对于他们之间的关系有一些想法。有没有一种可能，女主在之前的住院经历中生下了双胞胎呢。 影片的第一条事件与第三条事件重复度极高，如果导演有误导观众的意思，也就是第一事件真实发生，而且确实是自杀，但叙述片段使用的是女主引起的第三条事件，那么我觉得很没意思，纯纯把观众当傻子。 引用契诃夫的名言：“请将一切与故事无关的事物都从故事中移除。如果你说第一幕中有把枪挂在墙上，那么在第二幕或者第三幕中这把枪必须发射，不然就没必要挂在那。” 所以以我而言，如果第一条事件也是第三条事件，那么作为一个高智商精神病人，她入院的谎言就是故事的基础，在这个谎言的基础上，她想象出了自己如何能够走出精神病院的大致方案，也就是观众们看到的第一条女主作为侦探调查死亡的事件（这时是女主的想象，也是后来的现实），接着一环扣一环，女主逐步实现了计划。借用网友的一句话：女主在循环自己。 值得注意的是，除了开场是以女主视角来推进的以外，后来的故事基本都是第三视角看待女主，并非女主内心视角，因此对于观众所看到的，也是女主的“谎言”。 片尾女主自证时说老公没有留下任何蛛丝马迹，私人医生 Donadio 在苏黎世失踪了，她如何知道的？且她说私人医生失踪时，镜头切换到了院长警惕的神态，可以知道院长在思考怎样合适地揭穿她了，也就是说从这个时候起院长投不投票已经无所谓，他反正也“被迫”辞职了，事不关己，打那些医生的脸就行。后续就是私人医生 Donadio 马上回来说她在搞什么飞机。（这好像太明显了） 女主为了破案，强行伪装成偏执狂进精神病院这件事情本身也太偏执狂了。很符合院长说的优越感和自负。 至于说那几个帮助女主的医生可能与女主做了交易，或者那个女医生想顶替院长，我觉得有可能但概率不大。 所以总的来说，女主有精神问题，也确实是侦探，私人医生 Donadio 真实存在，女主给丈夫下毒也真实发生，丈夫恶意卷款送女主入院也真实发生，院长收钱了但是走的公账，他是真想治女主的病。 评价我觉得这部片很好，但是坏在哪里呢，坏就坏在故意引导观众去思考的部分过多了，会导致各种逻辑都无法自洽，观点对冲过多了，有一种用力过猛的不适感。 个人主观评价：7.5 分。","link":"/posts/40556/"},{"title":"全面拥抱二月","text":"二月相当努力，至少与这几个月的放荡相比是这样的。 关于笔记最重要的是有一直在写日记，而且有序的记录了自己的学习曲线。在之前是很难去想象的。对于笔记这个东西我曾走过很多弯路，当然现在也不一定是最好的最对的，但是相对来说还是有进步。 最开始也是一开始在电脑上记录，后来逐渐形成月制周制，倾向于写成一篇博客然后发布。说实话，将日记这种较为私密的记录生活的文字放载到公共空间，实在是不妥，一是隐私问题，二是有一种功利的心理——似是专门写给大家看的，而不是给自己看。 于是花了很长时间去思考日记的意义，然后选择了传统的手账日记（其实很大受到阿弥的影响）。虽说是手账，但那些复杂的、花里胡哨的装饰我是不屑和懒得去折腾的，于是还是单纯的只有文字（现在就算电子笔记也是如此，我觉得这样非常纯粹和易于管理）。那段日子发生的事相当记忆深刻，也许是因为特殊的人和事情，也许是因为用新买的钢笔和手账簿记录了。 很显然的，后来我又放弃了，原因很难想到，至少我一开始没想到：到学校寝室里，拿笔记时常容易被室友看到，就算看到里面一点点我也非常不舒服，但是我又很难在一天的结尾到外面去写日记。或许在床上写也是个不错的选择，但是非常不舒服，严重抑制了我写日记的热情。 于是又开始思考笔记、日记的记录方法，有什么又方便又舒适，又不会被窥探到的方法呢？ 最后选择了 Obsidian 本地使用 markdown 语言记录，解决了一些痛点，暂时用到现在。 对于被室友看到的解决方案：Obsidian 调整文字大小很方便，按住 Ctrl+滚轮 就可以调整，于是当我写私密文字的时候就可以将文字调整成最小，站在旁边的人是绝对看不清的，就算我坐着也有些吃力，但不至于看不了。 论方便程度，我是觉得还不错的，本地备份 + Onedrive + Obsidian 插件 实现全端备份，点一下就可以同步，电脑编辑完，手机上也可以接力，非常舒适。 Obsidian 的一些辅助插件也能提升码字的舒适度，包括但不限于模板、自动字符排版和双链等等。 除却日记，关于更多的笔记——课程的、自学的、读后感等等，也使用 Obsidian All in 了，打标签 + 文件夹管理的模式非常方便。 学了什么 java 基础复习了一半了，说的好听叫复习，其实之前学 java 时的一些细节问题根本没仔细解决，现在重学一遍，收获良多。 四级核心单词又过了一遍，这次相当认真，平均每天花了两个小时左右。 尤克里里方面，学会了《突然好想你》，但还有些地方不连贯，《未闻花名》还在练习，不过相当难。 日语学了基本五十音。 git 基础也重学了一下。 润的想法说实话可能是最近负面新闻接收太多了——也不知道是本身生活就是负面居多，还是刻意接收到的多了——最近这三年发生的大大小小的魔幻事件让我迷茫。 我不想谈论政治经济方面的问题，但是中国的生活像是蜘蛛网一样张开，并堆叠，而且亲情这个最大的网会把人罩的死死的。所以润是非常难的，我暂且不做考虑，但是会关注。 身体吃不消这个月熬夜有点狠了，一月份刚刚得过新冠，那段软弱体虚的时光让我难受至极，于是报复性的在二月熬了好多个夜，吃了不少垃圾食品。身体当然吃不消，有时候会胸闷，头晕，精力不足，还有日渐肥胖，哎，少熬夜，多锻炼，多睡觉，身体是革命的本钱！ 学校的垃圾课程想起来就烦，这学期居然安排了关于 ERP 企业资源管理系统的课，我不明白，我一个要做程序员的为什么要学这个。为了奖学金还得认真听（背）一下，应付那弱智的考试。 还有一些不作为的老师，教授一些过时的、甚至连他们自己都根本不深入明白的课程，我不好评价，只感觉浪费时间。 以及拉跨的机器改卷，不能识别多个正确答案为什么要机改，计算机领域哪有标准答案呢。 对比赛的思考上一年参与数模比赛拿到了还算不错的成绩，老师鼓励我继续冲，拿国奖，但是我已经开摆了，因为真的很累，不是比赛有多难，而是各种麻烦事的叠加让我厌倦。 比赛不是个人赛，而是团队赛，我虽然没什么本事，但还是要鼓起勇气当作队伍里的前锋、队长那样的角色，说实话，很累，我不喜欢指使他人，给别人分配任务，因为我怕选择了错误的方向。应该都有一种指令惰性吧，喜欢接收指令去干活，而不是发布指令。我不知道为什么会养成这种习惯，应该是不太好的习惯。也许和我从小乐于接受父母老师安排有关吧。 不过好在，花的时间虽然不算多也不算少，但有奖金，也不用去做麻木的体力劳动，稍微动点脑子就可以拿到钱，岂不美哉，所以这也是我参加的目的之一。而其他方面，学到了一些关于 matlab 和 latex 的知识，也算有用。 总的来说参加比赛还是不错的，能学到东西，也能挣钱，累不累看个人。但是那些要请正课的假去集训的比赛，我不好说，如果含金量不大或者拿不到大奖，还容易被挂科或者只能及格而拿不到奖学金，我觉得是有点亏的。 艺术方面这个月书和电影看得少了，虽然之前也不多。主要原因就是学习占用时间不少，而且在学校里琐事也多（比如上垃圾水课，嘈杂环境看书是一种折磨），于是几本在读书目基本没推进，也没看电影。 在有空的时候一般去图书馆了，在寝室里较为吵闹，不能学习，当然也无法欣赏一些作品。嘈杂是对艺术的扼杀。我想之后可以抠点时间出来在图书馆看电影，不过大家都在卷，而我在看电影，总觉得有些违和，不过我喜欢特立独行。我觉得每个年轻人都应该特立独行。 健身理念这个月没有运动，很全面的没有运动，大概是感染新冠给了自己一个借口：我好像很虚弱。但实际上我痊愈后天天熬夜吃外卖，对身体的伤害更大了。 近乎两个月的不运动，我有了全新的思考，因为运动是一件很消耗精力的事情，所以这件事情的确是有门槛的，而且不低。所以兴趣就是最最重要的一个前提，这可以使我不顾一些问题去向前冲。 所以之后的锻炼计划可能偏向于兴趣而非像以前一样为了肌肉、为了外表，这有点累了，生活本来就很累了，何苦自己呢。","link":"/posts/175/"},{"title":"关于2022","text":"混沌和迷茫的2022。这是一篇年终总结，关乎生活，不仅仅是学业上的一些东西。 死胡同起初重建博客的初衷是记录自己的关于编程方面的学习问题，但我走进了死胡同，既没有生活、也没有学习。单纯的笔记，可以通过本地化保存实现，并且更方便，所谓的博客，不该桎梏于所谓笔记，我发现，学习与生活绝对是无法相割裂开来的两个东西。 你说，当你遇到一个学习上的问题，你会如何去解决呢？解决方法，解决路径，这些种种程式化的，我本身而言是很讨厌的。尽管想成为一个有着清晰思路去妥善完成各种工作的人，但也绝非是这种。人从来是感性化的动物，我们不该剔除人性。于是我想再接下来的日子里，这个博客的主旋律也应该是生活。继续将生活好好记录，不管是通过文字还是各项媒介。 破碎的2022任谁而言，2022是满足和充实的呢。 已经记忆不起上半年发生的事情，好像魔幻的魔术橡皮擦在不经意间随手涂抹，我人生仅剩的百分之一时光已经消逝。 今年度过了人生中最为炎热的盛夏，炎热得仿佛不真实，脑子里只剩下空调外机和电风扇的嗡嗡噪音。酷热中重新拾起了守望先锋，遇到了一群网友，能够让我怀念起2016的那个夏天，但现在它要结束了，同样虚幻的不真实——2016年的我从未想象到守望先锋会迎来关闭国服的结局。 暑假曾回到母校看老师，没什么好讲的，老师很好，学校很好，我很不好。 在暑假结束，回学校的高铁上，我拿着平板赶着暑期社会实践的任务报告。接下来回到学校便是三天的数学建模比赛，通宵了一天，一天也是睡在教室，所幸取得一些名次，要不然会愤恨死自己，这么折腾自己的身体，如若没有什么结果，那对生理和心理都是莫大的伤害。 仍然闷热的十月份，来杭州这么久了，第一次去看了钱塘江。骑着自行车滑过拥挤的街道，细碎的晚风一边切割着银色的波浪，一边轻抚我燥热的胸膛。每隔几十米能见到在路上唱歌的人、跳舞的人和野餐的人，人各有各的幸福。左方能够望见钱塘江大桥，斑驳的车尾灯呼啸，在远处的我只见一丝丝红黄闪现而过。桥只管巨大的伫立在那里，无论如何。而我万不能伫立在原地，我得奔跑。 随同学去杭州各地景点摄影，正是在摄影的路上，我发现自己并不是喜欢摄影，只是喜欢好看的风景，摄影对于我而言，仅是保存那些画面的一个步骤。任意学问都有它自己的独特之处，我不揣摩我不明白也并不想深入的事物。 同样是十月份，在寝室的饮水机旁发现一颗蘑菇，顶好的生长着，尽管它第二天枯萎死去了。一定是饮水机漏水有点严重，12月份时饮水机也换新了，寝室没有人愿意搬它下楼，是我顺手搬下去了，再把新的抬上来。 蔡赠送了我一本2023的豆瓣日历，我那时想日子还远着呢，2022相当漫长啊，没想到要开始使用了。日历是个好东西，它能提醒我日子如水，淌着淌着就过去了。 如愿拿到了驾照，过程相当曲折，科目三是除高考外人生最折磨却不是最痛苦的实践经历，一无是处是书生，书本毫无作用。越长大越发现，所谓想回到小时候不是因为小时候有多舒服，有多快活，而是因为光是可以沉浸在书本当中，而不用去切身处理生活的琐碎，便已经是莫大的幸福了。 十一月份仍旧穿着短袖，酷热难耐，这回终于去了一趟动物园。说来惭愧，我从未去过动物园，唯一一次有机会，是在小学的某一次春游当中，而遗憾的是，那会儿老师好像说，因为成绩还是某些原因，某些同学不能去，很不巧，我就是那些同学之一，于是我在一个大家都去动物园的日子里放假了，但我没有伙伴可以一起玩耍，因为大家都在动物园。 熊、秃鹫、白虎、海狮等等动物，我只在视频中见过，如今见到了，相当欣喜。不过美中不足的是，动物们普遍无精打采，甚至带病上岗，动物也在疫情中累了么。最烦的是一个地方的许多大号鹦鹉，狂叫，震得耳膜生疼，没有看它们的欲望。最可惜的是，逛了一天也没找着熊猫馆，最后发现，原来在出口上写着熊猫馆维护了。袋鼠很可爱，于是狠狠的拍照，没有长焦镜头，也用数码变焦狠狠的放大来给它的肌肉一点特写。 突然的，十一月底下雪了，大片大片的雪花在身上落下，没见过几次大雪的南方孩子眼珠子已经离不开那些亮晶晶的雪花了。我后悔没有跟朋友们一起去堆雪人，现在来看，肯定是相当快活的回忆。 同样在十一月底，输掉了排球比赛，很懊恼，没有发挥应有的水平，虽然水平也不高，不过还是懊恼。接下来的日子，一定要狠狠的锻炼，狠狠的赢上那么几场比赛，狠狠的拍照庆祝，狠狠的在团建上喝上那么几杯。 12.7，《放牛班的春天》重映了，于是赶着去重温了一遍老师的温柔，坐在只有四个人的影院里，我觉得音乐是有灵魂的。 接下来就回家了，早早的回到了温州，然后在一次朋友聚会中阳了，卧病一周，刚好赶上了这年底。 恰好能从一年初始而重新开始计划和奋斗，这是非常好的开始。我喜欢开始这个词，能开始也是莫大的幸福。 该死的自律这年中，书没读几本，单词没背几个，身体也没好好的去锻炼，总而言之，是缺乏自律的一年。吃的是非常不健康但好吃的东西，作息是非常不健康但很爽的生物钟，学习方面也是三天打鱼两天晒网。当下过得非常愉快，但给我兜底的是我的人生。有人说每天百分之一的进步，日积月累会有很好的回报，而我每天百分之一的退步，那积累的错误是何等量级呢。 今年的自律，理应从早睡早起开始。 关于2023因为还年轻，一切都是变数，不是30岁的而立，不是40岁的中年，生活中心已经压在了一处，身子都无法挪移一点，重大的变动的后果是难以接受的，而年轻的我可以开始，在任何地方开始。 希望2023有更强壮的身体，更平和的心态，更聪明的大脑。 结每当动笔，就有一种没什么好写的感觉袭来，像傍晚飕飕的冷风，提醒你将步入阴寒的黑暗了。这种感受蔓延到任何事物，无论做什么都有一种不够及时的满足感。但不能止步于此，继续坚持着续写人生的长文吧。 各位新年吉祥。","link":"/posts/14413/"},{"title":"用Scrapy框架爬取豆瓣","text":"这是一项Python爬虫课的课程综合实践作业。 前情提要这个Python老师就喜欢整些花的，上课时间也飘忽不定，然后让我们用从来没用过的Scrapy框架在两天内自学完成一个简单爬虫，真不错，所以浅浅的学了一下，发现Scrapy爬虫的效率真的很高，而且稳定，用Xpath来定位标签也很方便。 分析目标网站是豆瓣电影TOP250，还是和之前差不多，250个电影为每页25个分为10页， 每个电影包含其电影海报、电影评分、电影评论等信息。不同的是之前通过正则表达式过滤来从源码中获取想要的信息，而且也用到了bs，因为re虽然匹配强，但是无法对信息顺序有一个记录，而这次使用Xpath来定位信息并抓取，相比手动撰写的re正则表达式，能够在F12中复制的Xpath可太舒服了。 代码创建Scrapy项目crapy startproject doubansp 创建一个爬虫先到刚才创建的文件夹下面： cd doubansp 再创建两个爬虫并指定名称和其域名(其实可以手动创建)： scrapy genspider pictureSpider movie.douban.com scrapy genspider imgdown movie.douban.com items.py在这个文件中定义一些容器来存放获取到的数据。 123456789101112131415161718192021# Define here the models for your scraped items## See documentation in:# https://docs.scrapy.org/en/latest/topics/items.htmlimport scrapyclass DoubanspItem(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() # 信息容器 movie_name = scrapy.Field() movie_star = scrapy.Field() movie_quote = scrapy.Field()class DoubanspItem2(scrapy.Item): # 图片容器 img_url = scrapy.Field() img_names = scrapy.Field() spiders/imgdown.py在这个文件中编写下载图片功能的爬虫代码。 这里使用custom_settings参数来指定这个爬虫使用的管道，防止图片下载的管道在运行获取信息的爬虫时造成数据错误。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import scrapyfrom scrapy.spiders import Spiderfrom scrapy.selector import Selectorfrom doubansp.items import DoubanspItem2class imgdown(Spider): # 爬虫名称 name = &quot;imgdown&quot; # 开始链接 start_urls = [&quot;https://movie.douban.com/top250&quot;] for i in range(1, 10): start_urls.append(&quot;https://movie.douban.com/top250?start=%d&amp;filter=&quot; % (25 * i)) # 指定使用管道 custom_settings = { 'ITEM_PIPELINES': { 'doubansp.pipelines.MyImagesPipeline': 100, } } # parse function def parse(self, response): item = DoubanspItem2() sel = Selector(response) # 使用xpath定位图片链接所在位置 images = sel.xpath('//*[@id=&quot;content&quot;]/div/div[1]/ol/li') # 定义图片链接与名称容器 item['img_url'] = [] item['img_names'] = [] # append the url and name of the image in item for image in images: # extract url and name of the image # 获取图片链接 site = image.xpath('div/div[1]/a/img/@src').extract_first() # 获取图片名称 img_name = image.xpath('div/div[1]/a/img/@alt').extract_first() # 获取电影排名顺序 rank = image.xpath('div[@class=&quot;item&quot;]/div[@class=&quot;pic&quot;]/em/text()').extract_first() item['img_url'].append(site) item['img_names'].append(rank + ' ' + img_name) yield item spiders/PicturespiderSpider.py在这个文件中编写获取电影数据的爬虫代码，名字有picture是因为一开始准备在这个文件里编写图片下载功能的，但是后面出了点问题又在另一个爬虫文件里写，然后懒得改这个名字了，有需求可以自己改一下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import reimport scrapyfrom scrapy.spiders import Spiderfrom scrapy.selector import Selectorfrom doubansp.items import DoubanspItemclass PicturespiderSpider(scrapy.Spider): # 设置模块名称 name = 'db' # 所爬取的域名 allowed_domains = ['movie.douban.com'] # 开始的网址 start_urls = ['https://movie.douban.com/top250'] # 指定使用管道 custom_settings = { 'ITEM_PIPELINES': { 'doubansp.pipelines.DoubanspPipeline': 100, } } def parse(self, response): # print(response.body) selector = Selector(response) # print(selector) # 定义Xpth所在标签，info包含一般电影信息 movies = selector.xpath('//div[@class=&quot;info&quot;]') for movie in movies: # 定位电影名称所在位置 movie_name = movie.xpath('div[@class=&quot;hd&quot;]/a/span/text()').extract() for i in range(0,len(movie_name)): movie_name[i] = re.sub('\\xa0/\\xa0', '', movie_name[i]) # 定位电影电影评分所在位置 movie_star = movie.xpath('div[@class=&quot;bd&quot;]/div[@class=&quot;star&quot;]/span[@class=&quot;rating_num&quot;]/text()').extract() # 定位电影评论所在位置 movie_quote = movie.xpath('div[@class=&quot;bd&quot;]/p[@class=&quot;quote&quot;]/span[@class=&quot;inq&quot;]/text()').extract() #print(movie_name) #print(movie_star) #print(movie_quote) item = DoubanspItem() # 将爬取到的信息放进item中的容器当中 item['movie_name'] = movie_name item['movie_star'] = movie_star item['movie_quote'] = movie_quote yield item # print(movie_name) # print(movie_star) # print(movie_quote) # 对下一页链接进行获取定位 next_page = response.selector.xpath('//span[@class=&quot;next&quot;]/link/@href').extract() if next_page: next_page = next_page[0] # 将下一页的标签参数进行更改递增25 yield scrapy.Request('https://movie.douban.com/top250' + next_page, callback=self.parse) pipelines.py在这个文件中，对Scrapy管道进行编辑，定义一个MyImagesPipeline类用于保存图片。 12345678910111213141516171819202122232425262728293031from itemadapter import ItemAdapterfrom scrapy import itemfrom scrapy.pipelines.images import ImagesPipelinefrom scrapy.http import Requestclass xsPipeline: def process_item(self, item, spider): return item# 图片下载管道class MyImagesPipeline(ImagesPipeline): def get_media_requests(self, item, info): if item['img_url'] is not None: for url in item['img_url']: yield Request(url, meta={'item': item, 'index': item['img_url'].index(url)}) # rename the image # 保存图片 def file_path(self, request, response=None, info=None): # 获取图片 item = request.meta['item'] index = request.meta['index'] # 获取图片名称 image_name = item['img_name'][index] # 设置图片名称并保存 return 'img/%s.jpg' % (image_name) setting.py1234567891011121314151617BOT_NAME = 'doubansp'SPIDER_MODULES = ['doubansp.spiders']NEWSPIDER_MODULE = 'doubansp.spiders'# 指定编码格式FEED_EXPORT_ENCODING = 'utf-8'# 设置UAUSER_AGENT = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.5005.124 Safari/537.36 Edg/102.0.1245.41'# 设置管道顺序（因为在爬虫文件中指定了，其实没必要）ITEM_PIPELINES = {'doubansp.pipelines.DoubanspPipeline': 100, 'doubansp.pipelines.MyImagesPipeline':200 }IMAGES_URLS_FIELD = 'url'IMAGES_STORE = r'.' main.py令人折磨的其实是这里，因为我是分成两个爬虫写的，之前没有为图片爬虫指定管道，导致数据交叉产生错误，然后又使用scrapy自带的cmdline函数来执行启动爬虫的命令，它会导致执行完一条命令后，直接让程序关闭，然后就G了，所以想要多条爬虫按顺序运行，必须使用os.system函数来执行爬虫启动命令。 12345import osos.system(&quot;scrapy crawl imgdown&quot;)# 将爬取到的信息保存成josn文件os.system(&quot;scrapy crawl db -o douban.json -t json&quot;) 小结入门Scrapy的坑还是很多的，我从早到晚就为了解决指定管道的问题，一开始剑走偏锋像网上查到的使用IF语句在管道内判断是哪个爬虫调用，然后一直出BUG或者直接没用，最后才发现直接在爬虫里指定管道就可以了，小问题浪费大时间，典中典了。","link":"/posts/34819/"},{"title":"Java基础","text":"关于Java基础的杂记 第一章 序万丈高楼平地起。 第二章 概述java 转义字符\\\\t ：一个制表位，实现对齐功能\\\\n ：换行符\\\\\\ ：一个真实的斜杠\\\\” ： 一个真实的双引号\\\\’ ： 一个真实的单引号\\\\r ：一个回车，没有换行，将光标置于最前，逐个输出\\r 后的字符 注释 单行注释 1//需要注释的语句 多行注释 123/*这里是多行注释*/ Javadoc 注释 1234/** * @author lael * @version 1.0 */ 细节 注释语句不会执行。 代码规范 类、方法的注释，要以 javadoc 的方式来写。 非 javadoc 注释着重告诉维护者如何修改、为什么这样写，以及注意事项。 运算符和 = 两边加一个空格。 实际工作使用 UTF-8 编码格式。 行宽不超过 80 字符。 代码编写使用行尾风格或次行风格。 一段代码一个模块，尽量只写一个功能，避免混乱。 JDK、JRE、JVM 之间关系 JDK = JRE + JAVA 开发工具 JRE = JVM + 核心类库 第三章 变量变量注意事项 int 4 个字节、double 8 个字节，每个类型占用空间不同。 变量必须先声明，后使用。 变量在同一个作用域中不可重名。 变量 = 变量名 + 值 + 数据类型 （三要素）。 + 号 当 + 左右两边有一方为字符串，则做拼接运算。 两边均为数值类型，则做加法运算。 运算顺序为从左到右。 数据类型 数值型 整数：byte[1]、short[2]、int[4]、long[8] 浮点数（小数）：float[4]、double[8] 字符型 char[2]：存放单个字符，如 ‘a’ 布尔型 boolean[1]：存放 true/false 整型使用细节 java 整型常量默认为 int 类型，声明 long 型常量须后加 ‘l’ 或 ‘L’ bit：计算机中最小存储单位 byte：计算机中基本存储单位 1 byte = 8 bit 浮点型使用细节 默认为 double 类型，声明 float 型单精度常量须后加 ‘f’ 或 ‘F’ 表示形式： 十进制 科学计数法，如：5.12e10 = 5.12 x 1010 通常情况下应该使用 double，因为它比 float 更精确，而 float 会损失一些小数位 字符型使用细节 字符常量用单引号括起单个字符 允许使用转义字符 char 的本质是一个整数，所以可以直接给 char 赋值整数，输出时是对应 unicode 对应字符 char 类型可以进行运算 基本数据类型的转换 精度小的类型自动转换为精度大的数据类型 char int long float double byte short int long float double 有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的数据类型，再进行计算 精度大的赋值给精度小的数据类型就会报错 (byte, short) 和 char 之间不会相互自动转换 byte, short, char 三者之间可以计算，在计算时首先转换为 int 类型 boolean 不参与类型自动转换 强制转换细节 需要数据从大到小时，就需要使用强制转换 字符串转换基本类型12345678int num1 = Integer.parseInt(s5);double num2 = Double.parseDouble(s5);float num3 = Float.parseFloat(s5);long num4 = Long.parseLong(s5);byte num5 = Byte.parseByte(s5);boolean b = Boolean.parseBoolean(&quot;true&quot;);short num6 = Short.parseShort(s5);char num7 = s5.charAt(0); //获取字符串的第一个字符 转换错误类型，会抛出异常，程序终止 第四章 运算符% 取余，取模123456// % 取模，取余// 本质公式：a % b = a - a / b * bSystem.out.println(10 % 3); //1System.out.println(-10 % 3); //-1System.out.println(10 % -3); //1System.out.println(-10 % -3); //-1 ++ 自增 / — 自减123456789101112131415// ++ 自增int i = 10;i++; //自增 等价于 i = i + 1 =&gt; i = 11++i; //自增 等价于 i = i + 1 =&gt; i = 12System.out.println(&quot;i=&quot; + i);/*作为表达式使用前++ ：++i先自增后赋值后++ ：i++先赋值后自增*/int j = 8;// int k = ++j; //等价于 j = j + 1; k = j;int k = j++; //等价于 k = j; j = j + 1;System.out.println(&quot;k=&quot; + k + &quot;\\nj=&quot; + j); 逻辑运算符逻辑与 &amp;对于逻辑与，第一个条件为 false，后面条件仍会判断执行 短路与 &amp;&amp;对于短路与，第一个条件为 false，后面条件不再判断执行 逻辑或 |对于逻辑或，第一个条件为 true，后面条件仍会判断执行 逻辑或 ||对于短路或，第一个条件为 true，后面条件不再判断执行 异或操作 ^a ^ b，如果 a 与 b 结果不同，则为 true，否则为 false 取反操作 ~对参数二进制格式进行 01 取反 三元运算符条件表达式 ？ 表达式1 : 表达式2 如果条件表达式为 true，运算后的结果是表达式 1 如果条件表达式为 false，运算后的结果是表达式 2 1234int a = 10;int b = 99;int result = a &gt; b ? a++ : b--;System.out.println(&quot;result: &quot; + result + &quot;\\nb: &quot; + b); 原码、反码、补码重要：负数的计算，需要先从原码转换为反码，反码再转换为补码再进行位运算，运算完毕后，再依次转回反码、原码。 二进制的最高位是符号位：0 表示正数，1 表示负数。 正数源码、反码、补码都一样。 负数的 反码 = 它的原码符号位不变，其他位取反。 负数的 补码 = 反码 + 1，反码 = 补码 -1。 0 的反码，补码都是 0。 java 没有无符号数。 计算机运算都以补码方式运算。 看运算结果的时候，要看它的原码。 位运算符按位与 &amp;两者全为 1，结果为 1，否则为 0。 12345678//1. 先得到 2 的补码 =&gt; 2的原码 00000000 00000000 0000000 0000010//2. 3的补码 3的原码 00000000 00000000 0000000 0000011//3. 按位与 &amp;// 00000000 00000000 0000000 0000010// 00000000 00000000 0000000 0000011//4. 得到是运算后的补码，因为是正数，三码合一，也是原码// 00000000 00000000 0000000 0000010 =&gt; 2System.out.println(2&amp;3);//2 按位或 |两位有一个为 1，结果为 1，否则为 0 1234//1. 先得到 2 的补码 = 2的原码 00000000 00000000 0000000 0000010//2. 3的补码 = 3的原码 00000000 00000000 0000000 0000011//3. 按位或 | 得到 00000000 00000000 0000000 0000011 =&gt; 3System.out.println(2|3);//3 按位异或 ^两位有一个为 0，一个 1，结果为 1，否则为 0 1234//1. 先得到 2 的补码 = 2的原码 00000000 00000000 0000000 0000010//2. 3的补码 = 3的原码 00000000 00000000 0000000 0000011//3. 按位异或 ^ 得到 00000000 00000000 0000000 0000001 =&gt; 1System.out.println(2^3);//1 按位取反 ~0 -&gt; 1，1 -&gt; 0 123456789101112//1. 先得到 -2 的原码 10000000 00000000 00000000 00000010//2. -2 的反码 11111111 11111111 11111111 11111101//3. -2 的补码 11111111 11111111 11111111 11111110//4. ~-2 操作 00000000 00000000 00000000 00000001 运算后的补码//5. 运算后的原码就是 00000000 00000000 00000000 00000001 =&gt; 1System.out.println(~-2);//1//1. 得到2的补码 0000000 00000000 00000000 00000010 正数原码、补码、反码三合一//2. ~2 操作 11111111 11111111 11111111 11111101 运算后的补码（负数）//3. 运算后的反码 11111111 11111111 11111111 11111100 反码 = 补码 - 1（负数）//4. 运算后的原码 10000000 00000000 00000000 00000011 =&gt; -3System.out.println(~2); //-3 算数左移运算符 &lt;&lt;符号位不变，按二进制位数左移指定位数，低位补 0。 算数右移运算符 &gt;&gt;低位溢出，符号位不变，并用符号位补溢出的高位。 1234567//1. 先得到 -1 的原码 10000000 00000000 0000000 00000001//2. 得到反码 11111111 11111111 11111111 11111110//3. 转换为补码 11111111 11111111 11111111 11111111//4. &gt;&gt;2操作 11111111 11111111 11111111 11111111//5. 转换为反码 11111111 11111111 11111111 11111110//6. 转换为原码 操作 10000000 00000000 00000000 00000001 =&gt; -1int b = -1 &gt;&gt; 2; //-1 逻辑右移操作符 &gt;&gt;&gt;低位溢出，高位补 0。 标识符的命名规则和规范^cd9c26 标识符概念 Java 中对各种变量、方法和类等命名时使用的字符序列称为标识符 凡是自己起名字的地方都称为标识符 命名规则 由 26 个英文字母大小写，0-9，或$组成 不可以使用数字开头 不可以使用关键字和保留字，但可以包含 严格区分大小写，长度无限制 标识符不能包含空格 包名多单词组成时所有字母小写 例：com.hahah.cpm 类名 、接口名多单词组成时，所有单词首字母大写 [大驼峰] 例：TankShotGame 变量名、方法名多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写 [小驼峰] ^09fac8 例：tankShotGame 常量名所有字母都大写，多个单词时用下划线连接 例：定义一个所得税税率 TAX_RATE 进制二进制0,1，满 2 进 1，以 0b 或 0B 开头 转八进制从低位(右)开始，将二进制数每三位一组，转成对应八进制数。 例：0b11010101 转为八进制 0b11(3)010(2)101(5) = 325 十进制0-9，满 10 进 1 转二进制将十进制数不断除以 2，直到商为 0，再将每步得到的余数倒置，就是对应的二进制 例：十进制 34 转为二进制 0b100010 转八进制将十进制数不断除以 8，直到商为 0，再将每步得到的余数倒置，就是对应的八进制 例：十进制 131 转为八进制 0203 转十六进制将十进制数不断除以 16，直到商为 0，再将每步得到的余数倒置，就是对应的十六进制 例：十进制 237 转为十六进制 0xED 八进制0-7，满 8 进 1，以数字0开头 转二进制将八进制数每 1 位转换为对应 3 位二进制 例：八进制 0237 转为二进制 0b010011111 十六进制0-9以及A(10)-F(15)， 满 16 进 1，以0x或0X开头 A-F不区分大小写 转二进制将十六进制数每 1 位转换为对应 4 位二进制 例：十六进制 0x23B 转为二进制 0b001000111011 第五章 控制结构顺序控制从上到下逐行执行，中间没有任何判断和跳转，遵循向前引用原则。 分支控制if else如果表达式为 true，则执行语句块 1，如果表达式为 false，则执行语句块 2。 双分支： 12345if (表达式) { 语句块1;} else { 语句块2;} 多分支： 12345678910if(表达式1) { 语句块1;} else if(表达式2) { 语句块2;...} else if(表达式n) { 语句块n;} else { 语句块n+1;} 如果表达式 1 为 true，则执行语句块 1，如果表达式 1 为 false，则继续判断表达式 2，为 true 则执行语句块 2，以此类推。 特别说明： 多分支可以没有 else。 如果所有表达式都不成立，则默认执行 else 代码块。 嵌套分支： 12345678910111213141516171819if(表达式1) { if(表达式2) { 语句块1; } else { 语句块2; }} else { if(表达式3) { 语句块3; } else if(表达式4) { 语句块4; } else { if(表达式n) { 语句块n; } else { 语句块n+1; } }} 实际开发中，嵌套不要超过三层，可读性不好。 switch表达式对应一个值，当表达式的值等于值 1，就执行语句块 1，并break跳出 swtich，不等于值 1 便逐次与值 2、值 3……进行匹配。如果表达式和值一个都没有匹配上，就默认执行 default 语句块。 如果不加break，则发生穿透，执行完该值的语句块并继续进行下一个值的判断。 123456789101112131415switch(表达式) { case 值1: 语句块1; break; case 值2: 语句块2; break; … case 值n: 语句块n; break; default: 语句块n+1; break;} switch 细节讨论： 表达式数据类型应与case后的常量类型一致，或者是能够自动转换或比较的类型。如char与int类型可以相互转换。 switch 中的表达式的返回值必须是：byte, short, int, char, enum[枚举], String 中的一种。 case子句中的值必须是常量（1, ‘a’）或者是常量表达式，不能是变量。 default的子句是可选的，当没有匹配的case时，执行default。 break用于退出 switch，如果没有，程序会进行穿透，执行到 switch 结尾。 123456789101112131415161718192021222324252627//3. 季节判断，使用穿透。System.out.println(&quot;输入月份：&quot;);int season = myScanner.nextInt();switch (season) { case 3: case 4: case 5: System.out.println(&quot;春季。&quot;); break; case 6: case 7: case 8: System.out.println(&quot;夏季。&quot;); break; case 9: case 10: case 11: System.out.println(&quot;秋季。&quot;); break; case 1: case 2: case 12: System.out.println(&quot;冬季。&quot;); break; default: System.out.println(&quot;月份错误！&quot;);} switch 与 if 的比较 如果判断具体数值不多，并且符合 byte, short, int, char, enum[枚举], String 这六种类型，建议使用 switch 语句。 对于区间判断、结果为 boolean 类型的判断，使用 if 的范围更广。 循环控制for123for(循环变量初始化; 循环条件; 循环变量迭代) { 语句块; //只有一句语句可以省略 {}。} for 循环细节： 循环条件应返回一个布尔值的表达式。 初始化变量和变量迭代可以写到其他地方，分号不能省略。 12345int i = 1; //循环变量初始化for (; i &lt;= 10;) { System.out.println(&quot;你好&quot; + i); i++; //循环变量迭代} 循环变量初始值可以有多条初始化语句，但是要求类型一致，循环遍历迭代同理。 while先判断，再循环。 123while(条件表达式) { 语句块;} do while先执行，再判断，一定会执行一次。 123do { 语句块;}while(条件表达式); 循环嵌套将一个循环放在另一个循环体内，内层循环作为外层循环的执行代码。 九九乘法表： 1234567891011public static void main(String[] args) { System.out.println(&quot;乘法口诀表：&quot;); // 外层循环 for (int i = 1; i &lt;= 9; i++) { // 内层循环 for (int j = 1; j &lt;= i; j++) { System.out.print(j + &quot;*&quot; + i + &quot;=&quot; + j * i + &quot;\\t&quot;); } System.out.println(); }} 空心金字塔： 123456789101112131415161718192021222324//分析思路//化繁为简：//1. 先打印一个矩形//2. 打印半个金字塔//3. 打印整个金字塔 （一个循环中嵌套两个循环。先算星星，再算空格）//4. 打印空心金字塔 (第一个位置是*，最后一个位置也是*，最后一层全部是*)//5. 先死后活： 层数作为变量int totalLevel = 54; //层数for (int i = 1; i &lt;= totalLevel; i++) { //i为层数 //再打印星星之前需要打印空格，空格 = 总层数 -当前层 for (int k = 1; k &lt;= totalLevel -i; k++) { System.out.print(&quot; &quot;); } for (int j = 1; j &lt;= 2 * i - 1; j++) { //当前行第一个位置是*，最后一个位置也是*，最后一层全部是* if (j ==1 || j ==2 * i -1 || i == totalLevel) { System.out.print(&quot;*&quot;); } else { //其他情况输出空格 System.out.print(&quot; &quot;); } } System.out.println(); 空心菱形： 1234567891011121314151617181920212223242526272829303132333435363738/*化繁为简1. 打印一个金字塔 (空格个数为总层数-当前层)2. 打印菱形3. 打印空心菱形先死后活设置层数变量 */int n = 4; //层数int totalLevel = n/2;for (int i = 1; i &lt;= totalLevel; i++) { for (int k = 1; k &lt;= totalLevel - i; k++) { System.out.print(&quot; &quot;); } for (int j = 1; j &lt;= i * 2 -1; j++) { if (j == 1 || j == i * 2 - 1) { System.out.print(&quot;*&quot;); } else { System.out.print(&quot; &quot;); } } System.out.println();}for (int i = totalLevel - 1 ; i &gt;= 1; i--) { for (int k = 1; k &lt;= totalLevel - i; k++) { System.out.print(&quot; &quot;); } for (int j = 1; j &lt;= i * 2 -1; j++) { if (j == 1 || j == i * 2 - 1) { System.out.print(&quot;*&quot;); } else { System.out.print(&quot; &quot;); } } System.out.println(); 跳转控制breakbreak 语句可以强制终止所在所在循环，在嵌套循环中，break 仅影响当前所在循环。一个循环中可以不只有一个 break 语句。 break 语句出现在多层嵌套的语句块中，可以通过标签指明要终止的是哪一层语句块。 12345678910lable1:for (int j = 0; j &lt; 4; j++) { lable2: for (int i = 0; i &lt; 10; i++) { if (i == 2) { break; //等价 break label2 } System.out.println(&quot;i = &quot; + i); }} continuecountinue 与 break 的区别在于，countinue 并不是终止整个循环，而是中止最近的一次循环的当次迭代。 注意： continue 语句只能用在 while 语句、for 语句或者 foreach 语句的循环体之中，在这之外的任何地方使用它都会引起语法错误。 终止指的是结束整个循环，中止指的是结束循环的当次迭代（跳过）。 coutinue 语句出现在多层嵌套的语句块中，可以通过标签指明要中止的是哪一层语句块。 1234567891011 label1: for (int j = 0; j &lt; 4; j++) { label2: for (int i = 0; i &lt; 10; i++) { if (i == 2) {// continue; //等价于 coutinue label2 continue label1; } System.out.println(&quot;i = &quot; + i); } } return在方法中，return 表示跳出所在的方法。 注意：如果 return 在 main 中使用，将表示为退出程序。 12345678for (int i = 1; i &lt;= 5; i++) { if (i == 3) { System.out.println(&quot;你好&quot; + i); return; //当使用在方法时。表示跳出方法，如果在main中，表示退出程序 } System.out.println(&quot;Hello World!&quot;);}System.out.println(&quot;go on..&quot;); 第六章 数组、排序和查找数组数组可以存放多个同一类型的数据。数组也是一种数据类型，是引用类型（数组就是一组数据）。 12345678910//定义一个数组double[] hens = {3, 5, 1, 3.4, 2, 50};double sum = 0;//遍历数组得到所有元素的和for (int i = 0; i &lt; 6; i++) { System.out.println(&quot;第 &quot; + (i + 1) + &quot; 个元素的值：&quot; + hens[i]); sum += hens[i];}System.out.println(&quot;所有元素和：&quot; + sum); double[] 表示该数组为 double 类型的数组，数组名 hens。 {3, 5, 1, 3.4, 2, 50}表示该数组的值/元素，依次表示数组的第几个元素。 通过 数组名[下标] 来访问数组的元素，下标从 0 开始编号，第一个元素就是 hens[0]，第二个元素就是 hens[1]，以此类推。 动态初始化： 直接定义数组大小类型。数据类型[] 数组名 = new 数据类型[大小] 12int[] a = new int[3];//int 类型的名为 a 的数组存放了 3 个int类型的数据 先声明数组，再 new 分配空间。 123456//1. 声明数组int[] a;//或 int a[]，此方法不推荐使用//2. 分配空间a = new int[3]; //分配内存空间，可以存放数据 静态初始化数据类型[] 数组名 = {元素值1, 元素值2...} 12double[] hens = {3, 5, 1, 3.4, 2, 50};//注意：仅适用于有指定元素。 数组使用细节： 数组元素可以是任何数据类型，但是不能混用。 数组创建后如果没有赋值，会有默认值，char 为\\u0000，String 为 null，boolean 为 false。 数组属于引用类型，数组型数据是对象（）。 数组赋值机制（重要）： 基本数据类型赋值，这个值就是具体的数据（栈），而且相互不影响。 1int n1 = 2; int n2 = n1; 数组在默认情况下是引用转递，赋的值是地址（堆），实际数据存放在堆中相应地址空间。 12int [] arr1 = {1, 2, 3};int [] arr2 = arr1; 数组赋值手动内容拷贝方式，数据传递，非引用传递。 12345678910//数组内容拷贝，非地址int[] arr1 = {10, 20, 30};//创建一个新的数组arr2，开辟新的数据空间int[] arr2 = new int[arr1.length];//遍历 arr1，把每个元素拷贝到 arr2 对应位置for (int i = 0; i &lt; arr1.length; i++) { arr2[i] = arr1[i];} 数组操作： 翻转 方式一：元素逐个交换 1234567891011//定义数组int[] arr = {11, 22, 33, 44, 55, 66};int temp = 0;//共交换三次for (int i = 0; i &lt; arr.length / 2; i++) { temp = arr[i]; //临时变量保存需要替换的元素 arr[i] = arr[arr.length - i - 1]; arr[arr.length - i - 1] = temp;}System.out.println(Arrays.toString(arr)); 方式二：逆序遍历，赋值新数组 1234567891011//定义数组int[] arr = {11, 22, 33, 44, 55, 66};int[] arr2 = new int[arr.length];int temp = 0;//逆序遍历原数组，再存放入新数组for (int i = arr.length; i &lt;= 0; i--) { arr2[i] = arr[i];}arr = arr2; //arr原空间数据没有被变量引用，jvm自动销毁System.out.println(Arrays.toString(arr)); 扩容 123456789101112131415161718192021222324252627282930int[] arr = {1, 2, 3};Scanner sc = new Scanner(System.in);while (true) { System.out.println(&quot;请输入添加元素值：&quot;); int num = sc.nextInt(); //建立新数组用于存放新添加的元素 int[] arr2 = new int[arr.length + 1]; for (int i = 0; i &lt; arr.length; i++) { arr2[i] = arr[i]; } arr2[arr2.length - 1] = num; arr = arr2; System.out.println(&quot;添加成功！&quot;); System.out.println(Arrays.toString(arr)); //判断是否继续添加 System.out.println(&quot;是否继续添加（y/n）：&quot;); char yes = sc.next().charAt(0); if (yes == 'n') { break; } else if (yes == 'y') { System.out.println(&quot;继续添加！&quot;); } else { System.out.println(&quot;输入有误，退出程序！&quot;); break; }} 缩减 12345678910111213141516171819202122232425262728293031323334int[] arr = {1, 2, 3, 4, 5};Scanner sc = new Scanner(System.in);while (true) { //建立新数组用于存放缩减后的元素 int[] arr2 = new int[arr.length - 1]; for (int i = 0; i &lt; arr.length - 1; i++) { arr2[i] = arr[i]; } arr = arr2; System.out.println(&quot;缩减成功！&quot;); System.out.println(Arrays.toString(arr)); //判断是否能够继续缩减 if (arr.length == 1) { System.out.println(&quot;数组仅剩一位，无法继续缩减！&quot;); break; } //判断是否继续缩减 System.out.println(&quot;是否继续缩减（y/n）：&quot;); char yes = sc.next().charAt(0); if (yes == 'n') { break; } else if (yes == 'y') { System.out.println(&quot;继续缩减！&quot;); } else { System.out.println(&quot;输入有误，退出程序！&quot;); break; }} 排序将多个数据，依照指定的顺序进行排列的过程。 冒泡排序： 1234567891011121314151617int[] arr = {24, 69, 80, 57, 13};int temp = 0;boolean sorted = true;for (int i = 0; i &lt; arr.length - 1; i++) { for (int j = 0; j &lt; arr.length - i - 1; j++) { //如果前面的数大于后面的数，就交换 if (arr[j] &gt; arr[j + 1]) { temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; sorted = false; } } if (sorted) break; //如果某一轮没有交换了，代表已经有序，提前退出程序}System.out.println(Arrays.toString(arr)); 查找顺序查找： 从头到尾一一比对，成功则停止，不成功则继续。 123456789101112131415//定义一个字符串数组String[] names = {&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;dd&quot;};Scanner sc = new Scanner(System.in);System.out.println(&quot;请输入名字：&quot;);String findName = sc.next();//遍历数组，逐一比较for (int i = 0; i &lt; names.length; i++) { if (findName.equals(names[i])) { System.out.println(&quot;找到了！在第 &quot; + (i + 1) + &quot; 位。&quot;); return; //直接退出 }}System.out.println(&quot;没找到！&quot;); 二维数组数组的数组，即二维数组也是一个特殊的一维数组，其每个元素又是一个一维数组。 1数据类型[][] 数组名 = {{元素值1, 元素值2...}, {元素值1, 元素值2...}...} 123456789101112//定义二维数组int[][] arr = {{0, 0, 0, 0, 0, 0}, {0, 0, 1, 0, 0, 0}, {0, 2, 0, 3, 0, 0}, {0, 0, 0, 0, 0, 0}};//输出图形for (int i = 0; i &lt; arr.length; i++) { //遍历二维数组的每个元素（数组） for (int j = 0; j &lt; arr[i].length; j++) { System.out.print(arr[i][j] + &quot; &quot;); } System.out.println(); //换行} 二维数组中访问元素数组的元素：数组名[元素数组下标][元素数组中的元素的下标] 动态初始化： 直接定义数组。 123456789int arr[][] = new int[2][3];arr[1][1] = 7;//遍历for (int i = 0; i &lt; arr.length; i++) { for (int j = 0; j &lt; arr[i].length; j++) { System.out.print(arr[i][j] + &quot; &quot;); } System.out.println(); //换行} 先声明，再 new 分配空间。 1234//1. 声明数组int[][] a; //或者 int[] a[];//2. 分配空间a = new int[3][2]; //分配内存空间，可以存放数据 列数不确定 在多维数组中，列数可以不同。并且通过先声明，再分配空间的方式，有效节约不需要使用的一维数组（列）所占空间大小。 12345678910111213141516171819//有三个一维数组，但每个一维数组还没有开辟空间int[][] arr = new int[3][];for (int i = 0; i &lt; arr.length; i++) { //给每个一维数组开辟空间 //如果没有给一维数组new，那么arr[i]就是null arr[i] = new int[i + 1]; //遍历一维数组，并给元素赋值 for (int j = 0; j &lt; arr[i].length; j++) { arr[i][j] = i + 1; }}//遍历输出for (int i = 0; i &lt; arr.length; i++) { for (int j = 0; j &lt; arr[i].length; j++) { System.out.print(arr[i][j] + &quot; &quot;); } System.out.println(); //换行} 静态初始化 `数据类型[][] 数组名 =","link":"/posts/45350/"},{"title":"豆瓣电影TOP250爬虫","text":"这是一项Python爬虫课的期末作业。 前情提要Python爬虫课的期末作业是自由选择一个网站爬取，那我就本着多一事不如少一事的原则选了豆瓣电影Top250这个最模板化的网站，而且网上也有很多很多例子可以借鉴。别的不说，我也挺喜欢看电影的，刚好理一遍，慢慢看这250个电影。不过期末周哪个孩子有时间看电影啊！ 分析打开豆瓣电影Top250，可以看到电影按十个一页降序排列在页面中，而且电影相应的海报图片和简介以及评分和一句话的评价都整合在一个框架当中。整个豆瓣电影TOP250排行榜共有250个电影，以25个一页分为10页。 点击第二页，可以看到网站链接的变化：https://movie.douban.com/top250?start=25，从其中可以知道start参数即此页及其之前页的电影数量，以此类推start=0为第一页，start=25为第二页，start=50为第三页…… 通过肉眼观察和F12，可以知道每个电影所在的div框架是包含了他所有信息，所以要么通过正则来匹配需要爬的信息，要么通过bs4模块先提取需要的源码块再进行数据清洗。 代码我为了逻辑更清晰，将要爬取的信息分为成了不同的模块去爬取，电影名称，电影评价，电影图片等等，但是缺点很明显，代码量很大，数据清洗要根据不同情况分批进行，再存到不同列表中。 改进方法就是写一个爬取所有需要信息的正则与bs4模块提取的框架，将所有信息进行数据清洗，再放到一个列表中，这样效率会高很多，代码量也小。 此次代码用到了异常捕获，主要是为了防止图片下载失败，因为自己寝室里网络不错，运行完美，到了机房，访问豆瓣图片库有时候会G，所以要写一个重新尝试下载功能。 还有文件管理，启动程序前先检查需要的目录是否存在，是否有同名文件冲突，如果有则创建或删除。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178# -*- codeing = utf-8 -*-import reimport sqlite3import timeimport urllib.requestfrom bs4 import BeautifulSoupfrom prettytable import PrettyTable# 模拟浏览器headers = (&quot;User - Agent&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36&quot;)opener = urllib.request.build_opener()opener.addheaders = [headers]# 将opener安装为全局urllib.request.install_opener(opener)# 保存每页的链接def save_img_url(data): path=&quot;img_url.txt&quot; file=open(path,&quot;a&quot;) file.write(data+&quot;\\n&quot;) file.close()# 保存图片到本地def save_img(): for p in range(0,10): flag = True url = &quot;https://movie.douban.com/top250?start=&quot; + str(p * 25) data1 = urllib.request.urlopen(url).read().decode(&quot;utf-8&quot;) # 将每页的链接保存到本地 save_img_url(url) # 获取到所有海报图片链接头，无后辍.jpg pat = re.compile(r'&lt;img.*src=&quot;(.*?).jpg&quot;') # .*?表示字符出现一次或0次，re.S表示忽略换行 img_url = pat.findall(data1) for a_i in range(0, len(img_url)): loop = True # 使用一个while循环，在当爬取任意一张图片出现问题时，重新爬取一次 while loop: try: this_img = (img_url[a_i]) # 图片链接加入后缀.jpg this_img_url = this_img + &quot;.jpg&quot; print(this_img_url) img_path = &quot;img/&quot; + str((a_i + 1) + p * 25) + &quot;.jpg&quot; print(&quot;正在爬取第&quot;, str((a_i + 1) + p * 25), &quot;张图片&quot;) urllib.request.urlretrieve(this_img_url, img_path) time.sleep(0.1) # 每张图片下载间隔0.1秒 loop = False # 如果没问题就不循环了，有问题这条不执行而执行except中的内容 except: print(&quot;图片爬取错误，正在重试！&quot;)# 保存所有电影数据def save_all(): titles = [] kinds = [] ranks = [] quotes = [] viewns = [] for p in range(0,10): # 设置url并解析html url = &quot;https://movie.douban.com/top250?start=&quot; + str(p * 25) data1 = urllib.request.urlopen(url).read().decode(&quot;utf-8&quot;) #电影名称爬取 pat1 = re.compile(r'&lt;span class=&quot;title&quot;&gt;([^&amp;]+)&lt;/span&gt;',re.S) # .*?表示字符出现一次或0次，re.S表示忽略换行 [^&amp;]+即排除中间有&amp;号的一次或多次 ()内即为爬到的东西 title = pat1.findall(data1) # # 对得到的列表进行数据清洗 # for i in range(0,len(img_url)): # img_url[i] = re.sub('&amp;nbsp;/&amp;nbsp;', '', img_url[i]) titles = titles + title # print(titles) # 电影种类爬取 pat2= re.compile(r'&lt;br&gt;(.*?)&lt;/p&gt;',re.S) # .*?表示字符出现一次或0次，re.S表示忽略换行 kind = pat2.findall(data1) # 对得到的列表进行数据清洗 for i in range(0,len(kind)): kind[i] = re.sub('&amp;nbsp;', '', kind[i]) kind[i] = re.sub(' ', '', kind[i]) kind[i] = re.sub(' ', '', kind[i]) kind[i] = re.sub('\\n', '', kind[i]) kinds = kinds + kind # print(kinds) # 电影评分爬取 pat3 = re.compile(r'&lt;span class=&quot;rating_num&quot; property=&quot;v:average&quot;&gt;(.*?)&lt;/span&gt;',re.S) # .*?表示字符出现一次或0次，re.S表示忽略换行 rank = pat3.findall(data1) # # 对得到的列表进行数据清洗 # for i in range(0,len(img_url)): # img_url[i] = re.sub('&amp;nbsp;/&amp;nbsp;', '', img_url[i]) ranks = ranks + rank # print(ranks) # 电影评论人数爬取 url = &quot;https://movie.douban.com/top250?start=&quot; + str(p * 25) data1 = urllib.request.urlopen(url).read().decode(&quot;utf-8&quot;) # print(url) pat4 = re.compile(r'&lt;span&gt;(.*?)&lt;/span&gt;',re.S) # .*?表示字符出现一次或0次，re.S表示忽略换行 viewn = pat4.findall(data1) # 对得到的列表进行数据清洗 del viewn[0: 6] viewns = viewns + viewn # print(viewns) # 电影精华短评爬取 soup = BeautifulSoup(data1,&quot;html.parser&quot;) # 指定Beautiful的解析器为“html.parser” # 注：解析器负责把 HTML 解析成相关的对象，而 BeautifulSoup 负责操作数据（增删改查）。“html.parser” 是 Python 内置的解析器 for item in soup.find_all('div', class_=&quot;item&quot;): # 查找符合要求的字符串，形成列表(注：class是一个类别/属性，需要加下划线，否则会报错) # 这里的循环将每个item，即每个电影的代码框架遍历，共25个 pat5 = re.compile(r'&lt;span class=&quot;inq&quot;&gt;(.*)&lt;/span&gt;') # 从每个代码框架中找出评价，若没有评价，则将评论留空 item = str(item) quote = &quot;&quot;.join(re.findall(pat5, item)) # 将列表元素转换为字符串 if len(quote) != 0: quotes.append(quote) # 添加 else: quotes.append(&quot; &quot;) # 留空 # print(quotes) print(&quot;第&quot;, p+1, &quot;页爬取完毕&quot;) print(&quot;---------------------------&quot;) print(&quot;检查数据正确性：&quot;) print(&quot;影片名称个数&quot;, len(titles)) print(&quot;影片种类个数&quot;, len(kinds)) print(&quot;影片评分个数&quot;, len(ranks)) print(&quot;影片评分人数个数&quot;, len(viewns)) print(&quot;影片精华简评个数&quot;, len(quotes)) #将数据保存到SQL数据库 conn = sqlite3.connect('Spider.db') print(&quot;建立并打开数据库 Spider.db 成功！&quot;) c = conn.cursor() c.execute(''' create table Movie(ID int primary key not null, title varchar(50), kind varchar(50), ranks varchar(50), viewer varchar(50), quote varchar(50)); ''') print(&quot;表Movie创建成功！&quot;) print(&quot;开始向Movie表插入数据&quot;) for i in range(0,len(titles)): c.execute(''' insert into Movie values(?,?,?,?,?,?); ''', (i+1, titles[i],kinds[i],ranks[i],viewns[i],quotes[i])) print(&quot;数据插入Movie成功！&quot;) conn.commit() conn.close()def select_sql(): # 创建放置查询结果的输出表格，设置其表头 tb = PrettyTable() tb.field_names = [&quot;ID&quot;, &quot;电影名称&quot;, &quot;种类&quot;, &quot;评分&quot;, &quot;评论人数&quot;, &quot;优秀短评&quot;] conn = sqlite3.connect('Spider.db') c = conn.cursor() print(&quot;开始查询SQL数据库的Movie表：&quot;) cursor = c.execute(&quot;SELECT * FROM Movie&quot;) for row in cursor: tb.add_row([row[0], row[1], row[2], row[3], row[4], row[5]]) print(tb) print(&quot;SQL数据库查询成功！&quot;) conn.commit() conn.close()def main(): print(&quot;开始爬取数据！&quot;) save_all() print(&quot;数据爬取完毕！4秒后开始爬取图片&quot;) print(&quot;---------------------------&quot;) time.sleep(4) save_img() print(&quot;图片爬取完毕！请在img目录下查看对应ID图片&quot;) print(&quot;4秒后开始查询数据库Movie表&quot;) print(&quot;---------------------------&quot;) time.sleep(4) select_sql()if __name__ == &quot;__main__&quot;: main() 小结这些代码陆陆续续写了十几个小时，因为之前上课一直摸鱼，老师讲的也很含糊，并没有想让我会的意思，于是基本上很多爬虫知识都是临时搜索和复制黏贴来的，不过有认真思考程序的运行思路与错误优化。","link":"/posts/45300/"},{"title":"车票管理系统","text":"这是Java课程的期末考试题之一。 前情提要Java老师发了四道题，说是期末考试时在其中每人随机抽一道作为考题。这属于很放水了，而且题目都不难，主要是考界面设计和人性化设计，大概是还没有学数据结构和算法的缘故，在代码思维上基本都不难。 所以保险起见都做掉了，这是其中一道。 分析问题： 利用所学的Swing控件，及不同的事件处理接口，设计一个火车订票用户界面。要求在一个JComboBox（下拉框）选择车票的种类（如：“杭州——&gt;宁波”），在文本框1中自动出现该票的单价，在文本框2中显示剩余票的张数。当用户在文本框3中输入购买的张数，并按下“购买”按钮时，在文本区中显示总价格，并要及时更新剩余张数。要求：合理应用布局设计，注意界面美观、友好。（可考虑异常处理） 使用Swing控件设计成了一个比较小的窗口，麻雀虽小，五脏俱全（其实还想做个车次编辑但是懒） 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220package com.test.four;import javax.swing.JFrame;import javax.swing.JComboBox;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.ItemEvent;import java.awt.event.ItemListener;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;import javax.swing.DefaultComboBoxModel;import javax.swing.JLabel;import javax.swing.JOptionPane;import javax.swing.JTextField;import javax.swing.JButton;public class Demo { private static JTextField tf_price; private static JTextField tf_sytk; private static JTextField tf_buytk; private static JTextField tf_start; private static JTextField tf_finish; private static JTextField tf_hdtk; private static JComboBox cb; private static JButton bt_buy; private static JButton bt_add; private static JButton bt_del; public static void main(String[] args) { JFrame myFrame = new JFrame(&quot;火车订票&quot;); myFrame.setVisible(true); myFrame.setSize(300,200); myFrame.getContentPane().setLayout(null); cb = new JComboBox(); cb.setModel(new DefaultComboBoxModel(new String[] {&quot;宁波 → 杭州&quot;, &quot;温州 → 杭州&quot;})); cb.setBounds(10, 10, 130, 21); myFrame.getContentPane().add(cb); JLabel lblNewLabel = new JLabel(&quot;\\u5355\\u4EF7\\uFF1A&quot;); lblNewLabel.setBounds(177, 69, 56, 15); myFrame.getContentPane().add(lblNewLabel); tf_price = new JTextField(); tf_price.setBounds(220, 66, 54, 21); myFrame.getContentPane().add(tf_price); tf_price.setColumns(10); JLabel label = new JLabel(&quot;\\u5269\\u4F59\\u7968\\u6570\\uFF1A&quot;); label.setBounds(153, 41, 62, 15); myFrame.getContentPane().add(label); tf_sytk = new JTextField(); tf_sytk.setColumns(10); tf_sytk.setBounds(220, 38, 54, 21); myFrame.getContentPane().add(tf_sytk); bt_buy = new JButton(&quot;购买&quot;); bt_buy.setBounds(153, 121, 121, 23); myFrame.getContentPane().add(bt_buy); JLabel label_1 = new JLabel(&quot;购买票数：&quot;); label_1.setBounds(153, 96, 62, 15); myFrame.getContentPane().add(label_1); tf_buytk = new JTextField(); tf_buytk.setColumns(10); tf_buytk.setBounds(220, 93, 54, 21); myFrame.getContentPane().add(tf_buytk); bt_add = new JButton(&quot;添加新票&quot;); bt_add.setBounds(10, 121, 130, 23); myFrame.getContentPane().add(bt_add); JLabel label_2 = new JLabel(&quot;出发地&quot;); label_2.setBounds(10, 41, 62, 15); myFrame.getContentPane().add(label_2); tf_start = new JTextField(); tf_start.setColumns(10); tf_start.setBounds(77, 38, 63, 21); myFrame.getContentPane().add(tf_start); JLabel label_2_1 = new JLabel(&quot;目的地&quot;); label_2_1.setBounds(10, 69, 62, 15); myFrame.getContentPane().add(label_2_1); tf_finish = new JTextField(); tf_finish.setColumns(10); tf_finish.setBounds(77, 66, 63, 21); myFrame.getContentPane().add(tf_finish); JLabel label_2_2 = new JLabel(&quot;核定票数：&quot;); label_2_2.setBounds(10, 96, 62, 15); myFrame.getContentPane().add(label_2_2); tf_hdtk = new JTextField(); tf_hdtk.setColumns(10); tf_hdtk.setBounds(77, 93, 63, 21); myFrame.getContentPane().add(tf_hdtk); JButton bt_del = new JButton(&quot;删除&quot;); bt_del.setBounds(153, 9, 121, 23); myFrame.getContentPane().add(bt_del); // 设置窗体关闭确认，关闭窗体时结束进程 myFrame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE); // 设置关闭窗体时什么也不做 myFrame.addWindowListener(new WindowAdapter() { // 配置窗体监听器，如果窗体关闭，执行命令 public void windowClosing(WindowEvent w) { System.exit(0); } }); int[][] tk = new int [100][2]; tk[0][0] = 50; tk[0][1] = 30; tk[1][0] = 30; tk[1][1] = 100; tf_sytk.setText(String.valueOf(tk[0][0])); tf_price.setText(String.valueOf(tk[0][1])); ItemListener a = new ItemListener() { //定义下拉列表监视器 public void itemStateChanged(ItemEvent e) { if (e.getStateChange() == e.SELECTED) { //定义为执行一次 tf_sytk.setText(String.valueOf(tk[cb.getSelectedIndex()][0])); tf_price.setText(String.valueOf(tk[cb.getSelectedIndex()][1])); } } }; cb.addItemListener(a); ActionListener b = new ActionListener() { public void actionPerformed(ActionEvent e) { boolean eq = true; if (e.getSource() == bt_add) { try { if (tf_start.getText().equals(tf_finish.getText())) { JOptionPane.showMessageDialog(null, &quot;出发地和目的地不能相同！&quot;); tf_start.setText(&quot;&quot;); tf_finish.setText(&quot;&quot;); } else { String str = tf_start.getText() + &quot; → &quot; + tf_finish.getText(); for (int i = 0; i &lt; cb.getItemCount(); i++) { if (str.equals(cb.getItemAt(i))) { eq = false; break; } } if (eq) { tk[cb.getItemCount()][0] = Integer.parseInt(tf_hdtk.getText()); tk[cb.getItemCount()][1] = Integer.parseInt(tf_price.getText()); cb.addItem(str); cb.setSelectedIndex(cb.getItemCount()-1); tf_hdtk.setText(&quot;&quot;); tf_start.setText(&quot;&quot;); tf_finish.setText(&quot;&quot;); JOptionPane.showMessageDialog(null, &quot;添加成功&quot;); } else { JOptionPane.showMessageDialog(null, &quot;车程已经存在！&quot;); tf_hdtk.setText(&quot;&quot;); tf_price.setText(&quot;&quot;); tf_start.setText(&quot;&quot;); tf_finish.setText(&quot;&quot;); } } } catch (Exception e2) { if (tf_start.getText().length() == 0 || tf_finish.getText().length() == 0) { JOptionPane.showMessageDialog(null, &quot;出发地和目的地都不能为空！&quot;); } else { JOptionPane.showMessageDialog(null, &quot;票数和单价都必须为数值且不能为空！&quot;); } } } if (e.getSource() == bt_del) { if (cb.getSelectedIndex() == cb.getItemCount() - 1) { cb.removeItemAt(cb.getSelectedIndex()); } else { for (int i = cb.getSelectedIndex(); i &lt; cb.getItemCount() - 1; i++) { tk[i][0] = tk[i+1][0]; tk[i][1] = tk[i+1][1]; } cb.removeItemAt(cb.getSelectedIndex()); } } if (e.getSource() == bt_buy) { try { int nums = Integer.parseInt(tf_buytk.getText()); int price = tk[cb.getSelectedIndex()][1]; if (nums == 0) { JOptionPane.showMessageDialog(null, &quot;购票数不可为0！&quot;); } else if (nums &lt;= tk[cb.getSelectedIndex()][0] &amp;&amp; tk[cb.getSelectedIndex()][0] &gt; 0) { tk[cb.getSelectedIndex()][0] = tk[cb.getSelectedIndex()][0] - nums; JOptionPane.showMessageDialog(null, &quot;购票成功，共&quot; + nums *price + &quot;元!&quot;); } else if (tk[cb.getSelectedIndex()][0] == 0) { JOptionPane.showMessageDialog(null, &quot;抱歉，此车程已经售罄！&quot;); } else { JOptionPane.showMessageDialog(null, &quot;抱歉，您购买的票数超过了库存！&quot;); } tf_sytk.setText(String.valueOf(tk[cb.getSelectedIndex()][0])); } catch (Exception e2) { JOptionPane.showMessageDialog(null, &quot;购买票数不可为空&quot;); } } } }; bt_add.addActionListener(b); bt_del.addActionListener(b); bt_buy.addActionListener(b); }} 打包后的.jar可执行文件 小结这题没有难度，算是Swing的练手，虽然没有人用这个东西了，但生活的意义就是没有意义不是么。","link":"/posts/45713/"}],"tags":[{"name":"Hello World","slug":"Hello-World","link":"/tags/Hello-World/"},{"name":"HADOOP","slug":"HADOOP","link":"/tags/HADOOP/"},{"name":"分布式","slug":"分布式","link":"/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"踩坑","slug":"踩坑","link":"/tags/%E8%B8%A9%E5%9D%91/"},{"name":"LINUX","slug":"LINUX","link":"/tags/LINUX/"},{"name":"SHELL","slug":"SHELL","link":"/tags/SHELL/"},{"name":"Latex","slug":"Latex","link":"/tags/Latex/"},{"name":"排版","slug":"排版","link":"/tags/%E6%8E%92%E7%89%88/"},{"name":"数学建模","slug":"数学建模","link":"/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"MATLAB","slug":"MATLAB","link":"/tags/MATLAB/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"上帝的笔误","slug":"上帝的笔误","link":"/tags/%E4%B8%8A%E5%B8%9D%E7%9A%84%E7%AC%94%E8%AF%AF/"},{"name":"电影","slug":"电影","link":"/tags/%E7%94%B5%E5%BD%B1/"},{"name":"悬疑","slug":"悬疑","link":"/tags/%E6%82%AC%E7%96%91/"},{"name":"剧情","slug":"剧情","link":"/tags/%E5%89%A7%E6%83%85/"},{"name":"月记","slug":"月记","link":"/tags/%E6%9C%88%E8%AE%B0/"},{"name":"思考","slug":"思考","link":"/tags/%E6%80%9D%E8%80%83/"},{"name":"健身","slug":"健身","link":"/tags/%E5%81%A5%E8%BA%AB/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"复盘","slug":"复盘","link":"/tags/%E5%A4%8D%E7%9B%98/"},{"name":"年终总结","slug":"年终总结","link":"/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"name":"计划","slug":"计划","link":"/tags/%E8%AE%A1%E5%88%92/"},{"name":"豆瓣","slug":"豆瓣","link":"/tags/%E8%B1%86%E7%93%A3/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"爬虫","slug":"爬虫","link":"/tags/%E7%88%AC%E8%99%AB/"},{"name":"课综","slug":"课综","link":"/tags/%E8%AF%BE%E7%BB%BC/"},{"name":"Scrapy","slug":"Scrapy","link":"/tags/Scrapy/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"作业","slug":"作业","link":"/tags/%E4%BD%9C%E4%B8%9A/"},{"name":"二维数组","slug":"二维数组","link":"/tags/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/"}],"categories":[{"name":"日常","slug":"日常","link":"/categories/%E6%97%A5%E5%B8%B8/"},{"name":"笔记","slug":"笔记","link":"/categories/%E7%AC%94%E8%AE%B0/"},{"name":"生活","slug":"生活","link":"/categories/%E7%94%9F%E6%B4%BB/"},{"name":"编程","slug":"编程","link":"/categories/%E7%BC%96%E7%A8%8B/"},{"name":"Java","slug":"编程/Java","link":"/categories/%E7%BC%96%E7%A8%8B/Java/"},{"name":"Python","slug":"编程/Python","link":"/categories/%E7%BC%96%E7%A8%8B/Python/"}]}